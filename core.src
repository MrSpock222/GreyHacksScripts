list.get = function(x)
	for e in self
		if e.name == x then return e
	end for
	return null
end function

MainFuncsForCode = {}
MainFuncsForCode.Config = {}
MainFuncsForCode.Config.availableCfgs = {}
//config RSHELL PORT config
MainFuncsForCode.Config.availableCfgs.rshellPort = {}
MainFuncsForCode.Config.availableCfgs.rshellPort.type = "num"
MainFuncsForCode.Config.availableCfgs.rshellPort.value = 1000
//config RSHELL PORT config

//config DATABASE config
MainFuncsForCode.Config.availableCfgs.useDB = {}
MainFuncsForCode.Config.availableCfgs.useDB.type = "bool"
MainFuncsForCode.Config.availableCfgs.useDB.value = 1
//config DATABASE config

//config STARTWITHCLEARCONSOLE config
MainFuncsForCode.Config.availableCfgs.startWithClearConsole = {}
MainFuncsForCode.Config.availableCfgs.startWithClearConsole.type = "bool"
MainFuncsForCode.Config.availableCfgs.startWithClearConsole.value = 0
//config STARTWITHCLEARCONSOLE config

//config USEEXTDEC config
MainFuncsForCode.Config.availableCfgs.useExtDec = {}
MainFuncsForCode.Config.availableCfgs.useExtDec.type = "bool"
MainFuncsForCode.Config.availableCfgs.useExtDec.value = 0
//config USEEXTDEC config

MainFuncsForCode.Config.Init = function
	configName = "t.cfg"
	shell = get_custom_object["Shells"][0].shell
	if MainFuncsForCode.checkuser(shell) == "root" then configPath = "/root/Config/" else configPath = "/home/" + MainFuncsForCode.checkuser(shell) + "/Config/"
	comp = shell.host_computer
	configFile = comp.File(configPath + configName)
	if not configFile then 
		print("Creating config file...")
		res = comp.touch(configPath,configName)
		if typeof(res) == "string" then print("Error: " + res)
	end if

	cfgs = @MainFuncsForCode.Config.availableCfgs

	for cfg in cfgs.indexes
		MainFuncsForCode.Config.Set(cfg,cfgs[cfg].values[1])
	end for
end function
MainFuncsForCode.Config.Manager = function
	if launch_path.matches("kit") then return print("Config not available in kit")
	cfgs = @MainFuncsForCode.Config.availableCfgs

	option = MainFuncsForCode.chosesmth(cfgs.indexes,"Choose a config:")
	if option == -1 then return

	clear_screen
	cfg = cfgs.indexes[option]
	if cfgs[cfg].values[0] == "num" then
		currVal = "CurrVal: " + MainFuncsForCode.Config.Get(cfg)
		while true
			clear_screen
			print("##########" + cfg + "-CONFIG##########")
			userinput = user_input(currVal + char(10) + "Value>",false,false).trim.to_int
			if typeof(userinput) != "number" then 
				if not currVal.matches("<color=red>Please enter only numbers or q to return") then currVal = currVal + char(10) + "<color=red>Please enter only numbers or q to return"
				if userinput == "q" then return MainFuncsForCode.Config.Manager
				continue
			end if
			clear_screen
			print(MainFuncsForCode.Config.Set(cfg,userinput))
			print("Returning...")
			wait(2)
			MainFuncsForCode.Config.Manager
			break
		end while
	else if cfgs[cfg].values[0] == "bool" then
		currOpt = MainFuncsForCode.Config.Get(cfg)
		while true
			clear_screen
			print("##########" + cfg + "-CONFIG##########")
			if currOpt == 1 then print("<mark=white>True") else print("<mark=white>False")
			
			userinput = user_input("##########" + cfg + "-CONFIG##########" + char(10) + "Choose a value or press q to return", false,true).trim.lower
			if userinput == "q" then 
				clear_screen
				print(MainFuncsForCode.Config.Set(cfg,currOpt))
				print("Returning...")
				wait(2)
				return MainFuncsForCode.Config.Manager
			end if
			if currOpt == 1 then currOpt = 0 else currOpt = 1
		end while
	end if

	
end function
MainFuncsForCode.Config.Get = function(cfgName)
	if launch_path.matches("kit") then return null
	configName = "t.cfg"
	shell = get_custom_object["Shells"][0].shell
	if MainFuncsForCode.checkuser(shell) == "root" then configPath = "/root/Config/" else configPath = "/home/" + MainFuncsForCode.checkuser(shell) + "/Config/"
	comp = shell.host_computer
	configFile = comp.File(configPath + configName)
	if not configFile then MainFuncsForCode.Config.Init
	configFile = comp.File(configPath + configName)

	cont = configFile.get_content.split(char(10))

	for a in cont
		if a.matches(cfgName) then return a.split(" ")[1].to_int
	end for

	return null
end function
MainFuncsForCode.Config.Set = function(cfgName,value = 1)
	if program_path.matches("kit") then return
	configName = "t.cfg"
	shell = get_custom_object["Shells"][0].shell
	if MainFuncsForCode.checkuser(shell) == "root" then configPath = "/root/Config/" else configPath = "/home/" + MainFuncsForCode.checkuser(shell) + "/Config/"
	comp = shell.host_computer
	configFile = comp.File(configPath + configName)
	if not configFile then MainFuncsForCode.Config.Init
	configFile = comp.File(configPath + configName)

	cont = configFile.get_content.split(char(10))

	for a in range(0,cont.len-1)
		if cont[a].matches(cfgName) then 
			cont[a] = cont[a].split(" ")[0] + " " + value
			configFile.set_content(cont.join(char(10)))
			return "Set config entry: " + cfgName + " " + value
		end if
	end for

	cont.push(cfgName + " " + value)
	configFile.set_content(cont.join(char(10)))
	return "Created config entry: " + cfgName + " " + value
end function

MainFuncsForCode.chosesmth = function(listOfVariables = ["option 1"], descriptionText = "No description set", removeInt = 0)
	markPrefix = "<mark=#D1D1D143>"
	infoPrefix = "<color=#FF0000df>"
	num = 0
	if removeInt > 0 then listOfVariables.remove(removeInt - 1)
	
	while (true)
		counter = 0
		clear_screen()
		print (descriptionText)
		
		print("-------------------------------------------")
		for variables in listOfVariables
			if counter == num then print(markPrefix + variables)
			if counter != num then print(variables)
			counter = counter + 1
		end for
		print("-------------------------------------------")

		key = user_input("Press Up or Down arrow Key<size=0%>", false, true)

		if (key == "DownArrow") or (key == "s") then
			num = num + 1
			if num > listOfVariables.len - 1 then num = 0
		else if (key == "UpArrow") or (key == "w") then
			num = num - 1
			if num < 0 then num = listOfVariables.len - 1
		else if key == "q" then 
			clear_screen
			return -1
		else
			clear_screen()
			print("You chose: " + (num + 1))
			return num
		end if
	
	end while
end function

MainFuncsForCode.choseInput = function(listOfVariables = ["option 1"], descriptionText = "No description set", keys = ["q"])
	while (true)
		input = user_input(descriptionText, false, false).trim.to_int
		if input <= listOfVariables.len and input >= 1 then 
			return input - 1
		else 
			if input == "q" or input == "" then 
				clear_screen
				return -1
			end if

			if keys then
				for key in keys
					if key == input then return input
				end for
			end if
		end if
		clear_screen
	end while
end function

MainFuncsForCode.overrideMemCode = function(toWriteMem, libInfo)
	toWriteMem = toWriteMem.split(" ")
	type = toWriteMem[2]
	mem = toWriteMem[5]
	value = toWriteMem[6]
	meminfo = mem + " " + value

	if type == "null" then 
		print("<color=red><size=120%>Exploit failed") 
		print("<color=blue>--------------------------------------------")
		return
	else 
		print("<color=orange>--></color> " + MainFuncsForCode.printMemWithColor(toWriteMem.join(" ")))
		print("<color=blue>--------------------------------------------")
	end if

	codesFile = MainFuncsForCode.getFiles(get_custom_object["Shells"][0].shell, "", ".Trash").get(codesFileName)

	if codesFile == null then
		hostComputer = get_custom_object["Shells"][0].shell.host_computer
		createResult = hostComputer.touch(codesPath, codesFileName)
		if typeof(createResult) == "number" then
			print("Codes file got created at given path " + codesPath)
		else if typeof(createResult) == "string" then 
			print(createResult)
			return null
		end if

		codesFile = MainFuncsForCode.getFiles(get_custom_object["Shells"][0].shell, "", ".Trash").get(codesFileName)
	end if
	lines = codesFile.get_content.split(char(10))
	
	index = lines.indexOf(libInfo)

	index = index + 1
	while lines[index].matches("Type")
		if lines[index].split(" ")[5] + " " + lines[index].split(" ")[6] == meminfo then break //matches does not work bc '+' from value is used as regex
		if index >= lines.len then break
		index = index + 1
	end while

	if toWriteMem[1] != "root" and toWriteMem[1] != "guest" and  toWriteMem[1] != "???" then toWriteMem[1] = "user" //save as user and not username
	if index != -1 then lines[index] = toWriteMem.join(" ") else return //idk why, safety?

	codesFile.set_content(lines.join(char(10)))
end function

MainFuncsForCode.getmemcodes = function(metaLib, isrouter, useDB = true, lan_inject)
	libInfo = metaLib.lib_name + " " + metaLib.version
	toWriteMem = []

	codesFile = MainFuncsForCode.getFiles(get_custom_object["Shells"][0].shell, "", ".Trash").get(codesFileName)

	if codesFile == null then
		hostComputer = get_custom_object["Shells"][0].shell.host_computer
		createResult = hostComputer.touch(codesPath, codesFileName)
		if typeof(createResult) == "number" then
			print("Codes file got created at given path " + codesPath)
		else if typeof(createResult) == "string" then 
			print(createResult)
			return null
		end if

		codesFile = MainFuncsForCode.getFiles(get_custom_object["Shells"][0].shell, "", ".Trash").get(codesFileName)
	end if

	lines = codesFile.get_content.split(char(10))

	index = lines.indexOf(libInfo)

	if index != null and useDB then
		clear_screen
		print("<color=blue>" + "<b>----------------------------------------------------</b>")
		print("Database found!")
		print("<color=orange><size=120%>" + libInfo)
		if isrouter then
			index = index + 1
			while lines[index].matches("Type")
				toWriteMem.push(lines[index].replace("\bcomputer\b(?!:bounce)","computer:bounce"))
				print(toWriteMem.len + ": " + MainFuncsForCode.printMemWithColor(toWriteMem[toWriteMem.len - 1]))
				index = index + 1
				if index >= lines.len then break
			end while
		else 
			index = index + 1
			while lines[index].matches("Type")
				toWriteMem.push(lines[index].replace("computer:bounce","computer"))
				print(toWriteMem.len + ": " + MainFuncsForCode.printMemWithColor(toWriteMem[toWriteMem.len - 1]))
				index = index + 1
				if index >= lines.len then break
			end while
		end if
	else
		memory = get_custom_object["mx0"].scan(metaLib)
		if memory == null then exit("Update your metaxploit.so libary!")

		Handle = {}
		Handle.router = function
			for mem in memory
				address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")
		
				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value, lan_inject[0])

					userName = MainFuncsForCode.checkuser(result)
					if userName != "root" and userName != "guest" and userName != "???" then userName = "user"

					if result == 1 or result == 0 then toWriteMem.push("Type: " + userName + " firewall_disable at memcode: " + mem + " " + value)
					if typeof(result) == "computer" then toWriteMem.push("Type: " + userName + " computer:bounce at memcode: " + mem + " " + value)
					if typeof(result) == "shell" or typeof(result) == "null" or typeof(result) == "file" then toWriteMem.push("Type: " + userName + " " + typeof(result) + " at memcode: " + mem + " " + value)
					print(toWriteMem.len + ": " + MainFuncsForCode.printMemWithColor("Type: " + MainFuncsForCode.checkuser(result) + " " + toWriteMem[toWriteMem.len - 1].split(" ")[2:].join(" ")))
				end for
			end for
		end function

		Handle.other = function
			for mem in memory
				address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")

				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value)

					userName = MainFuncsForCode.checkuser(result)
					if userName != "root" and userName != "guest" and userName != "???" then userName = "user"
					
					if typeof(result) == "number" then toWriteMem.push("Type: " + userName + " password_change at memcode: " + mem + " " + value)
					if typeof(result) != "number" then toWriteMem.push("Type: " + userName + " " + typeof(result) + " at memcode: " + mem + " " + value)
					print(toWriteMem.len + ": " + MainFuncsForCode.printMemWithColor("Type: " + MainFuncsForCode.checkuser(result) + " " + toWriteMem[toWriteMem.len - 1].split(" ")[2:].join(" ")))
				end for
			end for
		end function

		if isrouter then Handle.router else Handle.other

		if index == null then
			toWriteMem.insert(0,libInfo)
			toWriteMem = toWriteMem.join(char(10))
			if codesFile.get_content.trim == "" then cont = toWriteMem else cont = char(10) + toWriteMem
			codesFile.set_content(codesFile.get_content + cont)

			toWriteMem = toWriteMem.split(char(10))
			toWriteMem.remove(0)
		end if
	end if

	return toWriteMem
end function

MainFuncsForCode.memCodeSelection = function(metaLib, isrouter, useDB,lanInject)
	memory = MainFuncsForCode.getmemcodes(metaLib, isrouter, useDB,lanInject)
	if not memory then return

	text = "<color=blue>========================================" + char(10) +
	"<color=orange>n  </color>test all null values" + char(10) +
	"Choose a vulnerability:"
	option = MainFuncsForCode.choseInput(memory, text,["n"])
	if option == -1 then return
	clear_screen()

	XPLOITS = []
	if option == "n" then 
		for mem in memory
			if mem.matches("null") then XPLOITS.push(mem.split(" "))
		end for
	else 
		XPLOITS.push(memory[option].split(" "))
	end if

	for XPLOIT in XPLOITS
		res = MainFuncsForCode.handle.exploits([XPLOIT[2],XPLOIT[5],XPLOIT[6]], metaLib,isrouter,lanInject)
	end for

	if option == "n" then 
		if XPLOITS.len >= 1 then user_input("Press any key to continue")
		MainFuncsForCode.memCodeSelection(metaLib, isrouter, useDB,lanInject)
	end if

	if XPLOITS.len == 1 and typeof(res) == "null" then user_input("Press any button to continue")
end function

MainFuncsForCode.printMemWithColor = function(input)
	usercolor = "<color=#00ADF1>"
	typecolor = "<color=#CE5D01>"
	memcolor = "<color=#FF0000>"
	valcolor = memcolor

	input = input.split(" ")
	input[1] = usercolor + input[1] + "</color>"
	input[2] = typecolor + input[2] + "</color>"
	input[5] = memcolor + input[5] + "</color>"
	input[6] = valcolor + input[6] + "</color>"

	return input.join(" ")
	
end function

MainFuncsForCode.showAllPasswords = function(files, startFromMainFolder = true)

	holderPass = []
	holderMail = []

	for file in files
		if startFromMainFolder then
			while file.path != "/"
				file = file.parent
			end while
		end if
	
		if not file then return print(file.name + " not found.")
	
	
		allf = MainFuncsForCode.getFiles(file)
		passwd = allf.get("passwd")
		mailtxt = allf.get("Mail.txt")
	
		if passwd != null then
			passwd = passwd.get_content
			if passwd != null then 
				for pass in passwd.split(char(10))
					if pass == "" then continue
					if holderPass.indexOf(pass) == null then holderPass.push(pass)
				end for
			end if
		end if

		if mailtxt != null then
			mailtxt = mailtxt.get_content
			if mailtxt != null then 
				for mail in mailtxt.split(char(10))
					if mail == "" then continue
					if holderMail.indexOf(mail) == null then holderMail.push(mail)
				end for
			end if
		end if

	end for
	

	holderAll = holderPass + holderMail
	infoText = []

	counter = 1
	infoText.push("<color=yellow>=================================================")
	infoText.push("Passwords:")
	if holderPass.len == 0 then
		infoText.push("No credentials found.")
	else
		for f in holderPass
			if not f then continue
			infoText.push(counter + ": " + f)
			counter = counter + 1
		end for
	end if 

	infoText.push("<color=blue>-------------------------------------------------")
	infoText.push("Mails:")
	if holderMail.len == 0 then
		infoText.push("No credentials found.")
	else
		for f in holderMail
			if not f then continue
			infoText.push(counter + ": " + f)
			counter = counter + 1
		end for
	end if 

	if holderAll.len == 0 then return user_input("Nothing found :(")
	infoText.push("<color=yellow>=================================================")
	desc = "q - quit" + char(10) +
		   "w - deciphers all passwords and mails" + char(10) +
		   "e - deciphers all passwords" + char(10) +
		   "r - deciphers all mails" + char(10) +
		   "t - send to decipher terminal"
	infoText.push(desc)

	useExtDec = MainFuncsForCode.Config.Get("useExtDec")

	enabledText = "<color=blue>Use external decipher is <color=green>enabled"
	disabledText = "<color=blue>Use external decipher is <color=red>disabled"

	if useExtDec == 1 then 
		infoText.push(enabledText)
	else 
		infoText.push(disabledText)
	end if

	while true
		clear_screen
		print(infoText.join(char(10)))

		option = user_input("Choose: ",false,true).trim
		if option.lower == "t" then 
			if useExtDec == 1 then 
				useExtDec = 0 
				infoText[infoText.len-1] = disabledText
			else 
				useExtDec = 1
				infoText[infoText.len-1] = enabledText
			end if
			continue
		end if

		if (option.to_int > counter or counter <= option.to_int) and not option == "all" then continue 

		if option.lower == "q" then
			return
		else if option.lower == "w" then
			if useExtDec then
				MainFuncsForCode.dec.sendToHome(holderAll)
			else
				for a in range(0,holderAll.len - 1)
					MainFuncsForCode.PrintPassword(holderAll[a])
				end for
				user_input
			end if
		else if option.lower == "e" then
			if useExtDec then
				MainFuncsForCode.dec.sendToHome(holderPass)
			else
				for a in range(0,holderPass.len - 1)
					MainFuncsForCode.PrintPassword(holderPass[a])
				end for
				user_input
			end if
		else if option.lower == "r" then
			if useExtDec then
				MainFuncsForCode.dec.sendToHome(holderMail)
			else
				for a in range(0,holderMail.len - 1)
					MainFuncsForCode.PrintPassword(holderMail[a])
				end for
				user_input
			end if
		else if holderAll.hasIndex(option.to_int - 1) then
			if useExtDec then
				MainFuncsForCode.dec.sendToHome([holderAll[option.to_int - 1]])
			else
				MainFuncsForCode.PrintPassword(holderAll[option.to_int - 1])
				user_input
			end if
		else if option == "q" then
			break
		end if
		wait(0.5)
	end while
end function

MainFuncsForCode.getFiles = function(targetShell = null, x = "", excludeFolder = "")
	
	if typeof(targetShell) == "shell" then f = targetShell.host_computer.File("/")
	if typeof(targetShell) == "computer" then f = targetShell.File("/")
	if typeof(targetShell) == "file" then 
		f = targetShell
		while f.path != "/"
			f = f.parent
		end while
	end if
	x = x.trim
	if x.len > 3 then return null
	Files = []

	RecFunc = function(f)
		for fil in f.get_folders
			if fil.name == excludeFolder then continue
			
			if x == "" then
				Files.push(fil)
			else
				hasperm = true
				for perm in range(x)
					if not fil.has_permission(x[perm]) then 
						hasperm = false
						continue
					end if
				end for

				if hasperm then 
					Files.push(fil)
				end if

			end if

			for fe in fil.get_files

				if x == "" then
					Files.push(fe)
				else

					hasperm = true
					for perm in range(x)
						if not fe.has_permission(x[perm]) then
							hasperm = false
							continue
						end if
					end for
	
	
					if hasperm then 
						Files.push(fe)
					end if
				end if

			end for
			RecFunc(fil)
		end for
	end function

	RecFunc(f)
	
	return Files

end function

MainFuncsForCode.PrintPassword = function(line)

	userPass = line.split(":")
	if userPass.len != 2 then return ("decipher: wrong syntax")
	password = get_custom_object["mxc"].decipher(userPass[1])
	if not password then print("Can't find password :(")
	if password then
		get_custom_object["succeeded"] = true
		print("\nUser: " + userPass[0])
		print("Password: " + "<color=red>" + password)
	end if

end function

MainFuncsForCode.checkuser = function(result)
	user = ""
	rfile = null
	file = null
	if typeof(result) != "shell" and typeof(result) != "file" and typeof(result) != "computer" then return "???"
	if typeof(result) == "computer" then
		file = result.File("/home")
		rfile = result.File("/root")
	else if typeof(result) == "shell" or typeof(result) == "ftpshell" then
		file = result.host_computer.File("/home")
		rfile = result.host_computer.File("/")
	end if
	if rfile and rfile.has_permission("w") then
		user = "root"
	else if rfile and file then
		for folder in file.get_folders
			if folder.has_permission("w") and folder.name != "guest" then user = folder.name
		end for
	end if


	if typeof(result) == "file" then
	file = result
	if file.name != "/" then
		file = file.parent
		while file.name != "/"
			file = file.parent
		end while
	end if

	if not file then return "???"
	if file.has_permission("w") then user = "root"
		for folder in file.get_folders
			if folder.name == "root" then
				if folder.has_permission("w") then user = "root"
			end if
			if folder.name == "home" and user != "root" then
				for sub in folder.get_folders
					if sub.has_permission("w") and sub.name != "guest" then user = sub.name
				end for
			end if
		end for
	end if
	if user == "" then user = "guest"
	return user
end function

MainFuncsForCode.copytotarget = function(targetShell)
	
	loc = MainFuncsForCode.getFiles(targetShell, "wrx").get(MainFuncsForCode.checkuser(targetShell)).path
	kit = get_custom_object["Shells"][0].shell.host_computer.File(current_path + "/kit")
	
	kit.chmod("o+wrx")
	for file in kit.get_files
		file.chmod("o+wrx")
	end for

	if not kit then return print("Test kit is missing")

	print("Installing test-kit on target...")

	res = get_custom_object["Shells"][0].shell.scp(kit.path,loc, targetShell)
	if res == "string" then print("Error: " + res)

	kit.chmod("o-wrx")
	for file in kit.get_files
		file.chmod("o-wrx")
	end for

	return loc + "/kit/" + launch_path.split("/")[-1]
end function

MainFuncsForCode.kit = function(x, codesFileName)
    CreateKit = function
		shell = get_custom_object["Shells"][0].shell
        currComp = shell.host_computer
        testfile = currComp.File(launch_path)
		startTime = time

        if currComp.File(current_path + "/kit") then 
			print("<color=red>Test-kit already exists")
			return UpdateKit
		end if

        files = MainFuncsForCode.getFiles(shell, "",".Trash")
		metaxfile = files.get("metaxploit.so")
		cryptfile = files.get("crypto.so")
		codesFile = files.get(codesFileName)

        if not metaxfile then return print("Metaxploit lib is missing")
        if not cryptfile then return print("Crypto lib is missing")
        folderpath = current_path + "/kit"

        print("Creating test kit...")
        res = currComp.create_folder(current_path, "kit")
        if res == "string" then return print("Creation of kit folder failed: " + res)
        print("Creating metaxploit.so...")
        res = metaxfile.copy(folderpath,"metaxploit.so")
        if res == "string" then return print("Creation of metaxploit.so at " + folderpath + " failed.")
        print("Creating crypto.so...")
        res = cryptfile.copy(folderpath,"crypto.so")
        if res == "string" then return print("Creation of crypto.so at " + folderpath + " failed.")
		if codesFile then 
			print("Moving " + codesFileName + "...")
			res = codesFile.move(folderpath,codesFileName)
		end if
        if res == "string" then return print("Creation of " + codesFileName + " at " + folderpath + " failed.")
        print("Creating TEST...")
        res = testfile.copy(folderpath,launch_path.split("/")[-1])
        if res == "string" then return print("Creation of TEST at " + folderpath + " failed.")


		print("Finished in " + round(time-startTime,2) + "s")
        print("Test kit got created.")
    end function

	UpdateKit = function
		shell = get_custom_object["Shells"][0].shell
		testfile = shell.host_computer.File(launch_path)
		startTime = time

        files = MainFuncsForCode.getFiles(shell, "",".Trash")
		metaxfile = files.get("metaxploit.so")
		cryptfile = files.get("crypto.so")
		codesFile = files.get(codesFileName)

		if not metaxfile then return print("Metaxploit lib is missing")
		if not cryptfile then return print("Crypto lib is missing")
		folderpath = current_path + "/kit"

		print("<color=orange>--> Updating test kit...")
		print("Updating metaxploit.so...")
		res = metaxfile.copy(folderpath,"metaxploit.so")
		if res == "string" then return print("Update of metaxploit.so at " + folderpath + " failed.")
		print("Updating crypto.so...")
		res = cryptfile.copy(folderpath,"crypto.so")
		if res == "string" then return print("Update of crypto.so at " + folderpath + " failed.")
		print("Updating TEST...")
		res = testfile.copy(folderpath,launch_path.split("/")[-1])
		if res == "string" then return print("Update of TEST at " + folderpath + " failed.")
		print("Finished in " + round(time-startTime,2) + "s")
		print("Test kit update finished")
	end function

    // if not x then return print("Use kit launch/install")

    if x == "install" then
        CreateKit()
    end if

    if x == "launch" then
        if not get_custom_object["Shells"][0].shell.host_computer.File(current_path + "/kit") then 
            userChoice = ""
            while (true)
                userChoice = user_input("Test-kit does not exist.\nDo you want to create it and proceed? y/n ", false, true).trim
                if userChoice == "" then continue
                if userChoice.lower == "n" or userChoice.lower == "y" then break
            end while
            if userChoice.lower == "y" then 
                CreateKit()
            else
                return print("Launch kit interrupted")
            end if
        end if

        print("Updating metaxploit.so...")

		metaxlib = get_shell.host_computer.File("/lib/metaxploit.so") 
		if not metaxlib then metaxlib = MainFuncsForCode.getFiles(get_shell).get("metaxploit.so")

        res = get_shell.host_computer.File(metaxlib.path).copy(current_path + "/kit", "metaxploit.so")
        if res == "string" then return("Failed updating metaxploit.so at kit!")



        loc = MainFuncsForCode.copytotarget(Current.shell)
        
        launch(Current.shell, loc, password)
    end if
end function

MainFuncsForCode.rndIp = function()
    ip0 = floor((rnd * 220) + 2)
    ip1 = floor((rnd * 255))
    if ip0 == 10 then ip0 = 222
    if ip0 == 127 then ip0 = 223
    if (ip0 == 192 and ip1 == 168) or (ip0 == 172 and ip1 == 16) then ip1 = 255
    return ip0 + "." + ip1 + "." + floor((rnd * 256)) + "." + floor((rnd * 256)) //Generate a random ip, doesnt start with 1
end function

MainFuncsForCode.setHackshopIP = function
	aptclient = include_lib("/lib/aptclient.so")
	if not aptclient then aptclient = include_lib(current_path + "/aptclient.so")
	if not aptclient then exit("There is no aptclient.so at " + current_path + " or /lib")

	if not aptclient.search("metaxploit.so").is_match("not found") then return print("HackshopIP Found")
	ip = ""
	print("Searching for hackshopIP....")
	while(aptclient.search("metaxploit.so").is_match("not found"))
		if ip != "" then aptclient.del_repo(ip)
		ip = MainFuncsForCode.rndIp
		aptclient.add_repo(ip)
		aptclient.update
	end while
	print("HackshopIP Found\n" + ip)
end function

MainFuncsForCode.getTotalIpsConnected = function(router)
	islocal = get_router.public_ip == router.public_ip
	total = router.devices_lan_ip.sort

	if islocal then
		hold = []
		for ip in total
			if typeof(get_router(ip)) == "router" then hold.push(ip)
		end for

		for ip in hold
			r = get_router(ip).devices_lan_ip
			for i in r
				if total.indexOf(i) == null then total.push(i)
			end for
		end for
	end if

	return total
end function

MainFuncsForCode.handle = {}
MainFuncsForCode.handle.exploits = function(XPLOIT, metaLib, isrouter,lan_inject)
	Handle ={}
	Handle.shell = function
		shell = metaLib.overflow(XPLOIT[1], XPLOIT[2])
		if typeof(shell) != "shell" then return
		MainFuncsForCode.handle.shell(shell)

		return shell
	end function

	Handle.bounce = function
		if isrouter then inp = lan_inject[0] else inp = ""
		comp = metaLib.overflow(XPLOIT[1], XPLOIT[2], inp)
		if typeof(comp) != "computer" then return

		print("Visible ips:")
		for ip in lan_inject
			print(ip)
		end for
		print("--------------------------")

		text = "Type <color=orange><b>all<b></color> to scan all ips above" + char(10) +
				"Enter target IP>"
		userinput = user_input(text,false,false).trim

		length = 0
		if userinput == "all" then length = lan_inject.len-1

		if length == 0 then
			comp = metaLib.overflow(XPLOIT[1], XPLOIT[2], userinput)
			if typeof(comp) != "computer" then return
			MainFuncsForCode.handle.computer([comp])
		else
			comps = []
			for a in range(0,length)
				comp = metaLib.overflow(XPLOIT[1], XPLOIT[2], lan_inject[a])
				if typeof(comp) != "computer" then continue
				comps.push(comp)
			end for

			MainFuncsForCode.handle.computer(comps)
		end if
		
		return comp
	end function

	Handle.computer = function
		comp = metaLib.overflow(XPLOIT[1], XPLOIT[2])
		if typeof(comp) != "computer" then return
		MainFuncsForCode.handle.computer([comp])
		return comp
	end function

	Handle.file = function
		file = metaLib.overflow(XPLOIT[1], XPLOIT[2])
		if typeof(file) != "file" then return
		MainFuncsForCode.handle.file(file)
		return file
	end function

	Handle.firewall_disable = function
		res = metaLib.overflow(XPLOIT[1], XPLOIT[2])
		return res
	end function

	Handle.password_change = function
		userinput = user_input("Enter a password:", false, false).trim
		res = metaLib.overflow(XPLOIT[1], XPLOIT[2], userinput)
		return res
	end function

	Handle.nothing = function
		toWriteMem = []

		if isrouter then 
			result = metaLib.overflow(XPLOIT[1], XPLOIT[2], lan_inject[0])

			if result == 1 or result == 0 then toWriteMem.push("Type: " + MainFuncsForCode.checkuser(result) + " firewall_disable at memcode: " + XPLOIT[1] + " " + XPLOIT[2])
			if typeof(result) == "computer" then toWriteMem.push("Type: " + MainFuncsForCode.checkuser(result) + " computer:bounce at memcode: " + XPLOIT[1] + " " + XPLOIT[2])
			if typeof(result) == "shell" or typeof(result) == "null" or typeof(result) == "file" then toWriteMem.push("Type: " + MainFuncsForCode.checkuser(result) + " " + typeof(result) + " at memcode: " + XPLOIT[1] + " " + XPLOIT[2])
		else
			result = metaLib.overflow(XPLOIT[1], XPLOIT[2])
					
			if typeof(result) == "number" then toWriteMem.push("Type: " + MainFuncsForCode.checkuser(result) + " password_change at memcode: " + XPLOIT[1] + " " + XPLOIT[2])
			if typeof(result) != "number" then toWriteMem.push("Type: " + MainFuncsForCode.checkuser(result) + " " + typeof(result) + " at memcode: " + XPLOIT[1] + " " + XPLOIT[2])
		end if

		MainFuncsForCode.overrideMemCode(toWriteMem[0], metaLib.lib_name + " " + metaLib.version)


		return result
	end function

	if XPLOIT[0] == "null" then 
		return Handle["nothing"]
	else if XPLOIT[0] == "computer:bounce" then 
		return Handle["bounce"]
	else
		return Handle[XPLOIT[0]]
	end if
end function
MainFuncsForCode.handle.shell = function(shell)
	ismatch = false
	for s in range(Shells.len - 1,0)
		if Shells[s].localIP == shell.host_computer.local_ip and Shells[s].publicIP == shell.host_computer.public_ip then 
			ismatch = true
			break
		end if
	end for

	if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

	option = MainFuncsForCode.chosesmth(["1: Enter remotely", "2: Launch kit", "3: Start Terminal"],"Choose a option")
	if option == -1 then return

	Current.shell = shell
	Current.computer = Current.shell.host_computer
	Current.user = MainFuncsForCode.checkuser(shell)

	if option == 1 then MainFuncsForCode.kit("launch")
	if option == 2 then 
		while true
			clear_screen
			userinput = user_input("Exiting to terminal will shutdown test completely\nDo you want to proceed [y/n]><size=0%>", false, true).trim.lower
			if userinput == "y" then break
			if userinput == "n" then return
		end while
		get_custom_object["exit"] = "exit"
		Current.shell.start_terminal
		exit("Shutting down...")
	end if
end function

MainFuncsForCode.handle.computer = function(comps, option)
	if comps.len == 1 then 
		option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Open FXplorer"], "Choose a option")
		if option == -1 then return
		if option == 0 then MainFuncsForCode.showAllPasswords([comps[0].File("/")])
		if option == 1 then MainFuncsForCode.fileExplorer(comps[0])
	else if comps.len > 1 then
		files = []
		for comp in comps
			files.push(comp.File("/"))
		end for
		MainFuncsForCode.showAllPasswords(files)
	end if
end function

MainFuncsForCode.handle.file = function(file)
	option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Open FXplorer"], "Choose a option")
	if option == -1 then return
	if option == 0 then MainFuncsForCode.showAllPasswords([file])
	if option == 1 then MainFuncsForCode.fileExplorer(file)
end function

MainFuncsForCode.handle.nothing = function(res)
	if typeof(res) == "file" then MainFuncsForCode.handle.file(res)
	if typeof(res) == "computer" then MainFuncsForCode.handle.computer(res)
	if typeof(res) == "shell" then MainFuncsForCode.handle.shell(res)
end function

MainFuncsForCode.incLib = function(libName, alwayInstall = false)

	if not program_path.matches("kit") then
		aptclient = include_lib("/lib/aptclient.so")
		if not aptclient then aptclient = include_lib(parent_path(program_path) + "/aptclient.so")
		if not aptclient then exit("There is no aptclient.so at " + parent_path(program_path) + " or /lib")

		//Updating aptclient
		result = aptclient.update()
		if result == "" then
			print("Updating aptclient was succsessful!")
		else
			return print("Updating aptclient failed: " + result)
		end if
		//Updating aptclient

		print("Installing " + libName + "...")
		aptclient.install(libName, "/lib")
		lib = include_lib("/lib/" + libName)
	else
		lib = include_lib("/lib/" + libName)
		if not lib then lib = include_lib(parent_path(program_path) + "/" + libName)
		if not lib then lib = include_lib(MainFuncsForCode.getFiles(get_custom_object["Shells"][0].shell).get(libName).path)
		if lib then print("<color=red>Kit has found " + libName + " lib!") else print("<color=red>Kit has not found " + libName + " lib!")
	end if

	return lib
end function

MainFuncsForCode.fileExplorer = function(fileOrShell)

	if typeof(fileOrShell) == "computer" then fileOrShell = fileOrShell.File("/")

	if typeof(fileOrShell) == "file" then
		while fileOrShell.path != "/"
			fileOrShell = fileOrShell.parent
		end while

		mainfolder = fileOrShell
	end if

	if typeof(fileOrShell) == "shell" then mainfolder = fileOrShell.host_computer.File("/")


	num = 0
	depth = 0
	showPerms = false
	prev = []
	markPrefix = "<mark=#D1D1D143>"

	cont = mainfolder.get_files + mainfolder.get_folders
	clear_screen

	while (true)

		counter = 0
		clear_screen()
		print ("<color=red>X</color>plorer")
		print("<color=blue>===========================================")
		for variables in cont

			if showPerms then
				if counter == num then print(markPrefix + variables.name + "</mark>                          " + variables.permissions)
				if counter != num then print(variables.name + "                          " + variables.permissions)
			else
				if counter == num then print(markPrefix + variables.name)
				if counter != num then print(variables.name)
			end if



			counter = counter + 1
		end for
		if not cont then print("<color=orange>EMPTY")
		print("<color=blue>===========================================")

		desc = "             <rotate=90>>   </rotate>      W" + char(10) + "          <  <rotate=-90>>  </rotate>>   A  S  D" + char(10) + char(10) +
		"1 - Download file/folder" + char(10) +
		"2 - toggle permissions" +
		"<size=0%>"

		key = user_input(desc, false, true)

		if (key == "DownArrow") or (key == "s") then
			num = num + 1
			if num > cont.len - 1 then num = 0
		else if (key == "UpArrow") or (key == "w") then
			num = num - 1
			if num < 0 then num = cont.len - 1
		else if (key == "RightArrow") or (key == "d") then
			if not cont then continue
			if not cont[num].is_folder then 
				res = cont[num].get_content
				if typeof(res) == "string" then 
					clear_screen
					print ("<color=red>X</color>plorer")
					print("<color=blue>===========================================")
					print(cont[num].name)
					print(char(10) + res)
					print("<color=blue>===========================================")

					if cont[num].name.matches("Mail.txt") or cont[num].name.matches("passwd") or cont[num].name.matches("Bank.txt") then
						while true
							infoText = "Press 1 to send file to decipher" + char(10) +
							"Press q button to return<size=0%>"
							inp = user_input(infoText, false, true).trim
							if inp.lower == "q" then break
							if inp.to_int == 1 then 
								MainFuncsForCode.dec.sendToHome(res.split(" "))
								clear_screen
								user_input("Press any button to return<size=0%>", false, true)
								break
							end if
						end while
					else
						user_input("Press any button to return<size=0%>", false, true)
					end if
				end if
			end if
			if cont[num].is_folder then 
				prev.push(cont)
				depth = depth + 1
				cont = cont[num].get_files + cont[num].get_folders
				num = 0
			end if
		else if ((key == "LeftArrow") or (key == "a")) and depth != 0 then
			depth = depth - 1
			if depth < 0 then depth = 0

			cont = prev[depth]
			prev.remove(depth)
		else if key == "1" then
			if typeof(fileOrShell) != "shell" then 
				print("This feature is only available in shells")
				user_input("Press any button to return<size=0%>", false, true)
				continue
			end if
			destFolder = "/home/guest/Downloads"
			if has_permission(Shells[0].shell.host_computer.File("/"), "w") then destFolder = "/root/Downloads"

			clear_screen
			print("Starting download of " + cont[num].name + "...")
			res = fileOrShell.scp(cont[num].path, destFolder, Shells[0].shell)
			if res == 1 then 
				print("Successfully sent file to hostmachine")
				print("--> " + destFolder)
			end if
			if typeof(res) == "string" then print("<color=red>Error: " + res)

			print("<color=blue>===========================================")
			user_input("Press any button to return<size=0%>", false, true)
		else if key == "2" then 
			showPerms = not showPerms
		else if key == "q" then 
			clear_screen
			break
		end if


	end while
end function

MainFuncsForCode.farmLibs = function
	//TODO auto build database
	//Keep in mind to just use the memcodes and not overflow so no attack is happening
end function

MainFuncsForCode.showMails = function
	email = mail_login(user_mail_address,user_input("Password>",true).trim)

	mails = email.fetch

	for mail in mails
		print(mail)
	end for
end function

MainFuncsForCode.connectToWlan = function(amount = 1)
	comp = Shells[0].shell.host_computer

	//GET NET DEVICE
	netDevices = comp.network_devices.split(char(10))
	netDevice = null
	for device in netDevices
		if not device then continue
		device = device.split(" ")
		res = Current.crypt.airmon("start", device[0])
		if typeof(res) != "string" then 
			Current.crypt.airmon("stop", device[0])
			netDevice = device[0]
			break
		end if
	end for

	if not netDevice then return print("<color=red>No wifi interface found")
	//GET NET DEVICE END


	networks = comp.wifi_networks(netDevice)
	if amount > networks.len then return print("There are only " + networks.len + " available")
	if amount < 1 then amount = 1
	res = Current.crypt.airmon("start", netDevice)
	if res == -1 then return
	if typeof(res) == "string" then return print("There was an error while switching monitoring mode: " + res)

	vals = []
	for network in networks
		vals.push(network.split(" ")[1][:-1].to_int)
	end for

	vals.sort.reverse

	for a in range(amount - 1,0)
		print("<color=#0066EB>##############################################")

		index = null

		for e in range(0,networks.len-1)
			if networks[e].split(" ")[1][:-1].to_int == vals[a] then 
				index = e
				break
			end if
		end for

		network = networks[index].split(" ")
		bssid = network[0]
		essid = network[2]
		pwr = network[1][:-1].to_int
		potentialAcks = 300000/(pwr+15)
		bssid = network[0]
		print("Finishing after " + round(potentialAcks) + "acks...")
		startTime = time
		Current.crypt.aireplay(bssid,essid,potentialAcks)
	
		wpw = Current.crypt.aircrack(home_dir + "/file.cap")
		print("Finished after " + round(time - startTime,2) + "s")
		print("<color=orange>Wifi password for " + essid + " is " + wpw)

		if a == 0 then 
			// while true
			// 	userinput = user_input("Connect to best wlan [y/n] ",false,true).trim.lower
			// 	if userinput == "y" then break
			// 	if userinput == "n" then return
			// end while	
		
			comp.connect_wifi(netDevice,bssid,essid,wpw)
		end if
	end for


	Current.crypt.airmon("stop", netDevice)
	comp.File(home_dir + "/file.cap").delete

end function

MainFuncsForCode.dec = {}
MainFuncsForCode.dec.decipher = function(x)
	MainFuncsForCode.PrintPassword(x)
end function
MainFuncsForCode.dec.sendToHome = function(passwdFile)
	shell = get_custom_object["Shells"][0].shell
	comp = shell.host_computer
	fileName = "pws.db"
	filePath = parent_path(launch_path) + "/Config/"
	file = comp.File(filePath + fileName)

	if not file then return print("Home shell is not listening")
	currCont = file.get_content.split(" ")
	if typeof(passwdFile) == "file" then passwdFile = passwdFile.get_content.split(" ")
	all = currCont + passwdFile
	res = file.set_content(all.join(char(10)))
	if res then return print("File sent to home machine")
	if typeof(res) == "string" then return print("Could not send file to home machine: " + res)
	user_input("Press any button to return<size=0%>", false, true)
end function
MainFuncsForCode.dec.listenForSend = function
	shell = get_custom_object["Shells"][0].shell
	comp = shell.host_computer
	fileName = "pws.db"
	filePath = parent_path(launch_path) + "/Config/"
	file = comp.File(filePath + fileName)

	if not file then 
		res = comp.touch(filePath,fileName)
		if typeof(res) == "string" then return print("Creating " + fileName + " has failed: " + res)
	end if
	file = comp.File(filePath + fileName)

	startFileCont = file.get_content.split(char(10))
	print("Listening...")
	while true

		currFileCont = comp.File(filePath + fileName).get_content.split(char(10))

		if startFileCont != currFileCont then
			startTime = time
			for pw in range(startFileCont.len,currFileCont.len-1)
				currFileCont[pw] = currFileCont[pw].trim
				if currFileCont[pw] == "" then continue
				if currFileCont[pw].len < 33 then continue
				MainFuncsForCode.PrintPassword(currFileCont[pw])
				wait(0.02)
			end for

			startFileCont = currFileCont
			print("Finished in " + round(time-startTime,2) + "s")
			print("Waiting...")
		end if

		wait(2)
	end while
end function

MainFuncsForCode.buildPortMap = function(address)
	Target.info = []
	Target.ports = []

	portInfo = "PORTINDEX PORT STATUS SERVICE INFO LAN\n"
	allLanDevices = ""
	portIndex = 1
	ports = null

	isLanIp = is_lan_ip(address)

	if isLanIp then
		router = get_router
	else
		router = get_router( address )
	end if

	if router == null then return print("Ip address not found")

	if not isLanIp then
		ports = router.used_ports
	else
		ports = router.device_ports(address)
	end if

	if ports == null then return print("Ip address not found")

	if typeof(ports) == "string" then return print(ports)


	//PUSH ROUTER TO ADDRESS LIST
	service_info = router.kernel_version
	portInfo = portInfo + portIndex + " " + router.public_ip + " " + "gateway" + " " + "router" + " " + service_info + " " + router.local_ip + "\n"
	Target.ports.push(0)
	portIndex = portIndex + 1
	//PUSH ROUTER TO ADDRESS LIST

	for port in ports
		service_info = router.port_info(port)
		lan_ips = port.get_lan_ip
		port_status = "open"

		if(port.is_closed and not isLanIp) then
			port_status = "closed"
		end if

		if lan_ips == router.local_ip then continue
		portInfo = portInfo + portIndex + " " + port.port_number + " " + port_status + " " + service_info + " " + lan_ips + "\n"
		Target.ports.push(port)
		portIndex = portIndex + 1
	end for



	total = MainFuncsForCode.getTotalIpsConnected(router)

	for el in total
		c = router.device_ports(el)
		if typeof(c) == "string" then 
			allLanDevices = allLanDevices + "\n" + portIndex + " FIREWALL Detected @ addr: " + port.get_lan_ip
			portIndex = portIndex + 1
		else
			for port in c
				allLanDevices = allLanDevices + "\n" + portIndex + " " + port.port_number + " " + "internal" + " " + router.port_info(port) + " " + port.get_lan_ip
				portIndex = portIndex + 1
			end for
		end if
	end for


	//MAINMAP
	Target.info.push("Scanning IP: " + address)
	Target.info.push("Found: " + total.len + " machines connected!")
	Target.info.push(router.bssid_name + " : " + router.essid_name + "\n")
	Target.info = Target.info + total
	Target.info.push("-------------------------------------------")
	Target.info = Target.info + format_columns(portInfo).split("\n")
	Target.info.push("-------------------------------------------")
	Target.info = Target.info + format_columns(allLanDevices).split("\n")

	//FIREWALL RULES
	Target.info.push("ROUTER")
	if not firewall_rules(router) then 
		Target.info.push("No firewall rules detected.")
	else
		out = "ACTION PORT SOURCE-IP DESTINATION-IP\n"
		for rule in firewall_rules(router)
			out = out + rule + "\n"
		end for
		Target.info = Target.info + format_columns(out).split("\n")
	end if

	return Target.info
end function

MainFuncsForCode.getLanInject = function(address)

	ips = []
	if is_lan_ip(address) then 
		router = get_router
	else
		router = get_router(address)
	end if

	for ip in MainFuncsForCode.getTotalIpsConnected(router)
		if not ip.matches(router.local_ip) then ips.push(ip)
	end for

	return ips
end function