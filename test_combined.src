__version = "3.0"
__name = "test"

/////////////////////////////////////////////////////////CONFIG START/////////////////////////////////////////////////////////
password = "cola123"
hackshopip = "123.230.147.159" //If not set use apt-get
codesFileName = "codes.db" //
codesPath = "/root" //Default codes path if kit does not exist
/////////////////////////////////////////////////////////CONFIG END/////////////////////////////////////////////////////////

Target = {}
Target.router = null
Target.address = ""
Target.prevaddress = ""
Target.files = {}
Target.firewalls = {}
Target.firewalls.rules = []
Target.firewalls.ips =[]
Target.passwords = ""
Target.mails = ""

Current = {}
Current.shell = get_shell
Current.computer = Current.shell.host_computer
Current.user = active_user
Current.metaxploit = null
Current.aptclient = null
Current.crypt = null
Current.backup = null
wasSuccessfull = false

DEBUG = false
if DEBUG then
	Current.metaxploit = include_lib("/lib/metaxploit.so")
	Current.crypt = include_lib("/lib/crypto.so")
	Current.aptclient = include_lib("/lib/aptclient.so")
end if

if not get_custom_object.hasIndex("Shells") then get_custom_object["Shells"] = []
Shells = @get_custom_object["Shells"]

Shell = {}
Shell.shell = null
Shell.localIP = ""
Shell.publicIP = ""
Shell.setName = function(name)
	self.name = name
end function
Shell.create = function(shell, publicIP, localIP, name = "Shell")
	x = new Shell
	x.shell = shell
	x.localIP = localIP
	x.publicIP = publicIP
	x.name = name
	return x
end function

if Shells.len == 0 then Shells.push(Shell.create(Current.shell,Current.computer.public_ip,Current.computer.local_ip))


File = {}
File.object = null
File.name = ""
File.path = ""
File.type = ""
File.content = ""
File.create = function(name, path, type, content, object)
	x = new File
	x.name = name
	x.path = path
	x.type = type
	x.content = content
	x.object = object
	return x
end function

list.get = function(x)
	for e in self
		if e == x then return e
	end for
	return null
end function

startShellLocalIP = Current.computer.local_ip
startShellPublicIP = Current.computer.public_ip
isStartShell = function(shell)
	localIP = shell.host_computer.local_ip
	publicIP = shell.host_computer.public_ip
	if localIP == startShellLocalIP and publicIP == startShellPublicIP then return true
	return false
end function

MainFuncsForCode = {}
MainFuncsForCode.chosesmth = function(listOfVariables = ["option 1"], descriptionText = "No description set", removeInt = 0)
	markPrefix = "<mark=#D1D1D143>"
	infoPrefix = "<color=#FF0000df>"
	num = 0
	if removeInt > 0 then listOfVariables.remove(removeInt - 1)
	
		while (true)
		counter = 0
		clear_screen()
		print (descriptionText)
		
		print("-------------------------------------------")
		for variables in listOfVariables
			if counter == num then print(markPrefix + variables)
			if counter != num then print(variables)
			counter = counter + 1
		end for
		print("-------------------------------------------")

		key = user_input("Press Up or Down arrow Key<size=0%>", false, true)

		if (key == "DownArrow") or (key == "s") then
			num = num + 1
			if num > listOfVariables.len - 1 then num = 0
		else if (key == "UpArrow") or (key == "w") then
			num = num - 1
			if num < 0 then num = listOfVariables.len - 1
		else if key == "q" then 
			clear_screen
			return -1
		else
			clear_screen()
			print("You chose: " + (num + 1))
			return num
		end if
		
		end while
	
end function

MainFuncsForCode.getmemcodes = function(typeOfCode, metaLib)
	memory = null

	if DEBUG then return Current.metaxploit.scan(metaLib)

	for file in MainFuncsForCode.getFiles(get_custom_object["Shells"][0].shell, "", ".Trash")
		if file.name == "kit" then 
			codesPath = file.path
			break
		end if
	end for


	if get_custom_object["Shells"][0].shell.host_computer.File(codesPath + "/" + codesFileName) == null then
		hostComputer = get_shell.host_computer
		createResult = hostComputer.touch(codesPath, codesFileName)
		if typeof(createResult) == "number" then
			print("Codes file got created at given path " + codesPath)
		else if typeof(createResult) == "string" then 
			print(createResult)
			return null
		end if
	end if


	codesFile = get_custom_object["Shells"][0].shell.host_computer.File(codesPath + "/" + codesFileName)

	if codesFile == null then 
		print("codes.txt doesnt exist at path: " + codesPath) //ONLY FOR DEBUG REASONS.. SHOULD ALREADY BE CREATED IF NOT EXISTING
		return null
	end if

	codeCont = codesFile.get_content.split("\n")

	for line in codeCont
		if line == "" then break
		le = line.split(" ")
		if le[0] + " " + le[1] != typeOfCode then continue
		memory = line[line.indexOf("[") : line.indexOf("]") + 1]
		memory = memory.split("""")
		break
	end for

	if memory == null then
		memory = get_custom_object["mx0"].scan(metaLib)
		if memory == null then exit("Update your metaxploit.so libary!")
		toWriteMem = " " + memory

		if codesFile.get_content.trim == "" then cont = typeOfCode + toWriteMem else cont = char(10) + typeOfCode + toWriteMem
		


		get_custom_object["Shells"][0].shell.host_computer.File(codesPath + "/" + codesFileName).set_content(get_custom_object["Shells"][0].shell.host_computer.File(codesPath + "/" + codesFileName).get_content + cont)
	end if

	return memory
end function

MainFuncsForCode.showAllPasswords = function(file, startFromMainFolder = true)

	if startFromMainFolder then
		while file.path != "/"
			file = file.parent
		end while
	end if

	if not file then return print(file.name + " not found.")
	holderPass = []
	holderMail = []
	holderAll = []
	for f in MainFuncsForCode.getFiles(file)
		if f.content == null then continue
		if f.name == "passwd" and f.content != "" then 
			for a in f.content.split("\n")
				if a != "" and holderPass.indexOf(a) == null then holderPass.push(a)
			end for
		end if

		if f.name == "Mail.txt" and f.content != "" then 
			for a in f.content.split("\n")
				if a != "" and holderMail.indexOf(a) == null then holderMail.push(a)
			end for
		end if

		if (f.name == "Mail.txt" or f.name == "passwd") and f.content != "" then 
			for a in f.content.split("\n")
				if a != "" and holderAll.indexOf(a) == null then holderAll.push(a)
			end for
		end if
	end for

	counter = 1
	print("<color=yellow>=================================================")
	print("Passwords:")
	if holderPass.len == 0 then
		print("No credentials found.")
	else
		for f in holderPass
			if not f then continue
			print(counter + ": " + f)
			counter = counter + 1
		end for
	end if 

	print("<color=blue>-------------------------------------------------")
	print("Mails:")
	if holderMail.len == 0 then
		print("No credentials found.")
	else
		for f in holderMail
			if not f then continue
			print(counter + ": " + f)
			counter = counter + 1
		end for
	end if 

	if holderAll.len == 0 then return user_input("Nothing found :(")
	print("<color=yellow>=================================================")
	desc = "all - deciphers all passwords and mails" + char(10) +
		   "allp - deciphers all passwords" + char(10) +
		   "allm - deciphers all mails"
	print(desc)
	while true
		option = user_input("Choose: ")
		if (option.trim.to_int > counter or counter <= option.trim.to_int) and not option.trim == "all" then continue 

		if option == "" then
			return
		else if option == "all" then
			for a in range(0,holderAll.len - 1)
				MainFuncsForCode.PrintPassword(holderAll[a])
			end for
		else if option == "allp" then
			for a in range(0,holderPass.len - 1)
				MainFuncsForCode.PrintPassword(holderPass[a])
			end for
		else if option == "allm" then
			for a in range(0,holderMail.len - 1)
				MainFuncsForCode.PrintPassword(holderMail[a])
			end for
		else if holderAll.hasIndex(option.to_int - 1) then
			MainFuncsForCode.PrintPassword(holderAll[option.to_int - 1])
		else if option == "q" then
			break
		end if
		break
	end while
end function

MainFuncsForCode.getFiles = function(targetShell = null, x = "", excludeFolder = "")
	
	if typeof(targetShell) == "shell" then f = host_computer(targetShell).File("/")
	if typeof(targetShell) == "computer" then f = targetShell.File("/")
	if typeof(targetShell) == "file" then 
		f = targetShell
		while f.path != "/"
			f = f.parent
		end while
	end if
	x = x.trim
	if x.len > 3 then return null
	Files = []

	RecFunc = function(f)
		for fil in f.get_folders
			
			if x == "" then
				if fil.name == excludeFolder then continue
				Files.push(File.create(fil.name, fil.path,"d","",fil))
			else
				if fil.name == excludeFolder then continue

				hasperm = true
				for perm in range(x)
					if not fil.has_permission(x[perm]) then 
						hasperm = false
						continue
					end if
				end for

				if hasperm then 
					Files.push(File.create(fil.name, fil.path,"d","", fil))
				end if

			end if

			for fe in fil.get_files

				if x == "" then
					Files.push(File.create(fe.name, fe.path,"f",fe.get_content, fe))
				else

					if fe.name == excludeFolder then continue	
	
					hasperm = true
					for perm in range(x)
						if not fe.has_permission(x[perm]) then
							hasperm = false
							continue
						end if
					end for
	
	
					if hasperm then 
						Files.push(File.create(fe.name, fe.path,"f",fe.get_content, fe))
					end if
				end if

			end for
			RecFunc(fil)
		end for
	end function

	RecFunc(f)
	
	return Files

end function

MainFuncsForCode.PrintPassword = function(line)

	userPass = line.split(":")
	if userPass.len != 2 then return ("decipher: wrong syntax")
	password = Current.crypt.decipher(userPass[1])
	if not password then print("Can't find password :(")
	if password then
		get_custom_object["succeeded"] = true
		print("\nUser: " + userPass[0])
		print("Password: " + "<color=red>" + password)
	end if

end function

MainFuncsForCode.scanalllibs = function(files)
	for c in range(1,files.len)
		metaLib = Current.metaxploit.load(files[c - 1].path)
		if not metaLib then
			if DEBUG then print("Skipped NULL")
			continue
		end if
		typeOfCode = metaLib.lib_name + " " + metaLib.version
		print("Scanning: " + metaLib.lib_name + " " + metaLib.version)
		MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
	end for
end function

MainFuncsForCode.checkuser = function(result)
	user = ""
	rfile = null
	file = null
	if typeof(result) != "shell" and typeof(result) != "file" and typeof(result) != "computer" then return "???"
	if typeof(result) == "computer" then
		file = result.File("/home")
		rfile = result.File("/root")
	else if typeof(result) == "shell" or typeof(result) == "ftpshell" then
		file = result.host_computer.File("/home")
		rfile = result.host_computer.File("/")
	end if
	if rfile and rfile.has_permission("w") then
		user = "root"
	else if rfile and file then
		for folder in file.get_folders
			if folder.has_permission("w") and folder.name != "guest" then user = folder.name
		end for
	end if


	if typeof(result) == "file" then
	file = result
	if file.name != "/" then
		file = file.parent
		while file.name != "/"
			file = file.parent
		end while
	end if

	if not file then return "???"
	if file.has_permission("w") then user = "root"
		for folder in file.get_folders
			if folder.name == "root" then
				if folder.has_permission("w") then user = "root"
			end if
			if folder.name == "home" and user != "root" then
				for sub in folder.get_folders
					if sub.has_permission("w") and sub.name != "guest" then user = sub.name
				end for
			end if
		end for
	end if
	if user == "" then user = "guest"
	return user
end function

MainFuncsForCode.copytotarget = function(targetShell)

	paths = []

	for folder in MainFuncsForCode.getFiles(targetShell, "wrx")
		if folder.type == "d" then paths.push(folder.path)
	end for

	loc = paths.get("/root")
	if not loc then loc = paths.get("/home/" + MainFuncsForCode.checkuser(targetShell))

	kit = get_custom_object["Shells"][0].shell.host_computer.File(current_path + "/kit")
	
	kit.chmod("o+wrx")
	for file in kit.get_files
		file.chmod("o+wrx")
	end for

	if not kit then return print("Test kit is missing")

	print("Installing test-kit on target...")

	res = get_custom_object["Shells"][0].shell.scp(kit.path,loc, targetShell)
	if res == "string" then print("Error: " + res)

	kit.chmod("o-wrx")
	for file in kit.get_files
		file.chmod("o-wrx")
	end for

	return loc + "/kit/" + launch_path.split("/")[-1]
end function

MainFuncsForCode.kit = function(x)
    CreateKit = function
        currComp = get_custom_object["Shells"][0].shell.host_computer
        testfile = currComp.File(launch_path)
        paths = []
        names = []


        if currComp.File(current_path + "/kit") then return print("Test-kit already exists.")

        for file in MainFuncsForCode.getFiles(get_custom_object["Shells"][0].shell, "",".Trash")
            if file.type == "f" then 
                paths.push(file.path)
                names.push(file.name)
            end if
        end for

        if names.get("metaxploit.so") then 
            metaxpath = paths[names.indexOf("metaxploit.so")]
            metaxfile = currComp.File(metaxpath)
        end if
        if names.get("crypto.so") then 
            cryptopath = paths[names.indexOf("crypto.so")]
            cryptfile = currComp.File(cryptopath)
        end if
        if names.get("aptclient.so") then 
            aptpath = paths[names.indexOf("crypto.so")]
            aptfile = currComp.File(aptpath)
        end if

        if not metaxfile then return print("Metaxploit lib is missing")
        if not cryptfile then return print("Crypto lib is missing")
        if not aptfile then return print("Aptclient.so lib is missing")
        folderpath = current_path + "/kit"

        print("Creating test kit...")
        res = currComp.create_folder(current_path, "kit")
        //currComp.File(current_path + "/kit").chmod("o+wrx")
        if res == "string" then return print("Creation of kit folder failed: " + res)
        res = metaxfile.copy(folderpath,"metaxploit.so")
        if res == "string" then return print("Creation of metaxploit.so at " + folderpath + " failed.")
        res = cryptfile.copy(folderpath,"crypto.so")
        if res == "string" then return print("Creation of crypto.so at " + folderpath + " failed.")
        res = aptfile.copy(folderpath,"aptclient.so")
        if res == "string" then return print("Creation of aptclient.so at " + folderpath + " failed.")
        res = testfile.copy(folderpath,launch_path.split("/")[-1])
        if res == "string" then return print("Creation of t at " + folderpath + " failed.")
        print("Test kit got created.")
    end function

    // if not x then return print("Use kit launch/install")

    if x == "install" then
        CreateKit()
    end if

    if x == "launch" then
        if not get_custom_object["Shells"][0].shell.host_computer.File(current_path + "/kit") then 
            userChoice = ""
            while (true)
                userChoice = user_input("Test-kit does not exist.\nDo you want to create it and proceed? y/n ", false, true).trim
                if userChoice == "" then continue
                if userChoice.lower == "n" or userChoice.lower == "y" then break
            end while
            if userChoice.lower == "y" then 
                CreateKit()
            else
                return print("Launch kit interrupted")
            end if
        end if

        print("Updating metaxploit.so...")

        for file in MainFuncsForCode.getFiles(get_shell)
            if file.name == "metaxploit.so" then 
                path = file.path
                break
            end if
        end for
        res = get_shell.host_computer.File(path).copy(current_path + "/kit", "metaxploit.so")
        if res == "string" then return("Failed updating metaxploit.so at kit!")



        loc = MainFuncsForCode.copytotarget(Current.shell)
        wasSuccessfull = true
        launch(Current.shell, loc, "local")
    end if
end function

MainFuncsForCode.rndIp = function()
    ip0 = floor((rnd * 220) + 2)
    ip1 = floor((rnd * 255))
    if ip0 == 10 then ip0 = 222
    if ip0 == 127 then ip0 = 223
    if (ip0 == 192 and ip1 == 168) or (ip0 == 172 and ip1 == 16) then ip1 = 255
    return ip0 + "." + ip1 + "." + floor((rnd * 256)) + "." + floor((rnd * 256)) //Generate a random ip, doesnt start with 1
end function

MainFuncsForCode.setHackshopIP = function
	ip = ""
	print("Searching for hackshopIP....")
	while(Current.aptclient.search("metaxploit.so").is_match("not found"))
		if ip != "" then Current.aptclient.del_repo(ip)
		ip = MainFuncsForCode.rndIp
		Current.aptclient.add_repo(ip)
		Current.aptclient.update
	end while
	print("Found hackshopIP " + ip)
end function

Menu = {}
Menu.init = function()

	KitStart = function
		Current.metaxploit = include_lib(current_path + "/metaxploit.so")
		if not Current.metaxploit then Current.metaxploit = include_lib("/lib/metaxploit.so")
		Current.crypt = include_lib(current_path + "/crypto.so")
		if not Current.crypt then Current.crypt = include_lib("/lib/crypto.so")
	end function

	NormalStart = function
		if password != "" then
			while(true)
				if user_input("<size=80%>" + "<color=red>TEST" + "</size>" + "<pos=0%><voffset=-1.2em>" + "Password: " + "</color>",true).trim == password then break
				clear_screen
				print("<color=red><b>Wrong password</b>")
			end while
		end if

		clear_screen()
		print "\n<align=""center"">Hacking Tool" + char(169) + "</align>\n<align=""center""><size=50px>TEST</size></align>\n<align=""center"">" + "by" + " Notschge</align>\n"
		print "Initializing..."

		if not Current.computer.is_network_active then return

		Current.aptclient = include_lib("/lib/aptclient.so")
		if not Current.aptclient then Current.aptclient = include_lib(current_path + "/aptclient.so")
		if not Current.aptclient then exit("There is no aptclient.so at " + current_path + " or /lib")

		// //Check if hackshopIP is valid and addrepo if so
		// if hackshopip != "" and Current.aptclient.search("metaxploit.so").is_match("not found") then
		// 	Current.aptclient.add_repo(hackshopip)
		// 	Current.aptclient.update
		// 	if Current.aptclient.search("metaxploit.so").is_match("not found") then Current.aptclient.del_repo(hackshopip)
		// end if

		// //If valid hackshopIP has not been already found, adding manually
		// ip = ""
		// while(Current.aptclient.search("metaxploit.so").is_match("not found"))
		// 	print("<color=red>Hackshop not found!")
		// 	if ip != "" then Current.aptclient.del_repo(ip)
		// 	ip = user_input("<size=80%>" + "<color=red>TEST" + "</size>" + "<pos=0%><voffset=-1.2em>" + "Enter hackshopIP: " + "</color>",true).trim
		// 	if ip == "" then exit("Shutting down...")
		// 	Current.aptclient.add_repo(ip)
		// 	Current.aptclient.update
		// end while

		MainFuncsForCode.setHackshopIP
	
		print("Installing metaxploit.so")
		Current.aptclient.install("metaxploit.so", "/lib")
		Current.metaxploit = include_lib("/lib/metaxploit.so")
	
		print("Installing crypto.so")
		Current.aptclient.install("crypto.so", "/lib")
		Current.crypt = include_lib("/lib/crypto.so")
			

	end function

	if params then
		if params[0] == "local" then KitStart else exit("<color=red><size=120%>Test does not take parameters!</size></color>")
	else 
		NormalStart
	end if
		
	if not get_custom_object.hasIndex("mx0") then get_custom_object["mx0"] = Current.metaxploit

	

	
	mainFuncs = {}
	mainFuncs.scan = {}
	mainFuncs.scan.use = "Usage: scan [IPADDRESS]"
	mainFuncs.scan.description = "Scan for ports at desired IP"
	mainFuncs.scan.run = function(x)
		XPLOITS = []
		wasSuccessfull = false
		portIndex = 1
		portInfo = "PORTINDEX PORT STATUS SERVICE INFO LAN\n"
		allLanDevices = ""
		ports = null
		pr = []

		getAddress = function
			if not x then 
				if not Target.prevaddress then return null
				return Target.prevaddress
			else
				if x[0] == "rnd" then 
					ip = MainFuncsForCode.rndIp
					Target.prevaddress = ip
					return ip
				end if
				if not is_valid_ip(x[0]) then return Target.prevaddress
				Target.prevaddress = x[0]
				return x[0]
			end if
		end function

		Target.address = getAddress
		if not Target.address then return print(mainFuncs.scan.use)

		////////////////////MAIN SETUP////////////////////

		isLanIp = is_lan_ip(Target.address)


		if isLanIp then
			Target.router = get_router
		else
			Target.router = get_router( Target.address )
		end if

		if Target.router == null then return print("nmap: ip address not found")

		if not isLanIp then
			ports = Target.router.used_ports
		else
			ports = Target.router.device_ports(Target.address)
		end if

		if ports == null then return print("nmap: ip address not found")

		if typeof(ports) == "string" then return print(ports)
		

		//PUSH ROUTER TO ADDRESS LIST
		service_info = Target.router.kernel_version
		portInfo = portInfo + portIndex + " " + Target.router.public_ip + " " + "gateway" + " " + "router" + " " + service_info + " " + Target.router.local_ip + "\n"
		pr.push(0)
		portIndex = portIndex + 1
		//PUSH ROUTER TO ADDRESS LIST

		for port in ports
			service_info = Target.router.port_info(port)
			lan_ips = port.get_lan_ip
			port_status = "open"

			if(port.is_closed and not isLanIp) then
				port_status = "closed"
			end if

			if lan_ips == Target.router.local_ip then continue
			portInfo = portInfo + portIndex + " " + port.port_number + " " + port_status + " " + service_info + " " + lan_ips + "\n"
			pr.push(port)
			portIndex = portIndex + 1
		end for

		Target.firewalls.ips = []
		Target.firewalls.rules = []
		hold = []
		total = []

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NEEEDSS WOOORKS//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		for el in Target.router.devices_lan_ip
			total.push(el)
		end for

		Target.firewalls.ips.push(Target.router.local_ip)
		Target.firewalls.rules.push(firewall_rules(Target.router))

		for el in total
			for port in Target.router.device_ports(el)
				if typeof(port) != "port" then continue
				if Target.router.port_info(port).matches("unknown") then continue
				if allLanDevices.indexOf(port.port_number) != null and allLanDevices.indexOf(el) != null then continue
				allLanDevices = allLanDevices + "\n" + portIndex + " " + port.port_number + " " + "internal" + " " + Target.router.port_info(port) + " " + el
				portIndex = portIndex + 1
			end for
		end for

		
		for el in Target.router.devices_lan_ip
			if typeof(get_router(el)) == "router" then hold.push(el)
		end for

		for el in hold
			d = get_router(el).devices_lan_ip
			for e in d
				if total.indexOf(e) == null then total.push(e)
			end for
		end for

		for ip in total
			if typeof(get_router(ip)) != "router" then continue
			r = get_router(ip)
			Target.firewalls.ips.push(ip)
			Target.firewalls.rules.push(firewall_rules(r))
			for el in r.devices_lan_ip
				if el.matches(r.local_ip) then continue
				for port in r.device_ports(el)
					if typeof(port) != "port" then continue
					if r.port_info(port).matches("unknown") then continue
					if allLanDevices.indexOf(port.port_number) != null and allLanDevices.indexOf(el) != null then continue
					allLanDevices = allLanDevices + "\n" + portIndex + " " + port.port_number + " " + "internal" + " " + r.port_info(port) + " " + el
					portIndex = portIndex + 1
				end for
			end for
		end for
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NEEEDSS WOOORKS//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////printig desc/////////////////

		clear_screen()
		print ("Scanning IP: " + Target.address)

		print("Found: " + total.len + " machines connected!")
		print(Target.router.bssid_name + " : " + Target.router.essid_name + "\n")

		for el in total
			print(el)
		end for
		
		print("-------------------------------------------")
		for variables in format_columns(portInfo).split("\n")
			print(variables)
		end for
		print("-------------------------------------------")
		for variables in format_columns(allLanDevices).split("\n")
			print(variables)
		end for

		PrintRouterInfo = function
			if Target.firewalls.ips.len == 0 then 
				print("No firewalls detected.")
			else
				print("-------------------------------------------")
				for f in range(Target.firewalls.ips.len - 1)
					print("ROUTER")
					print(Target.firewalls.ips[f])
					if Target.firewalls.rules[f].len == 0 then 
						print("No firewall rules detected.")
					else
						out = "ACTION PORT SOURCE-IP DESTINATION-IP\n"
						for rule in Target.firewalls.rules[f]
							out = out + rule + "\n"
						end for
			
						print(format_columns(out))
					end if
					print("-------------------------------------------")
				end for
			end if
		end function

		option = 0
		while(true)
			print("<color=blue>========================================")
			print("Type <color=#AA8B02><b>info</b></color> for more info or chose a portindex")
			option = user_input("Choose port:", false, false)
			if option.trim.to_int <= pr.len and option.trim.to_int >= 1 then
				option = option.trim.to_int - 1
				if option != 0 then 
					if pr[option].is_closed then
					print("Port is closed...")
					continue
					end if
				end if
				break
			end if
			if option.trim == "info" then PrintRouterInfo
			if option.trim == "" then return menu.run
		end while

		/////////////////printig desc/////////////////

		////////////////////MAIN SETUP END////////////////////
		if option == 0 then //Option for router
		
			net_session = Current.metaxploit.net_use(Target.address)
			if not net_session then return print("Error: can't connect to net session")
			metaLib = net_session.dump_lib
			typeOfCode = metaLib.lib_name + " " + metaLib.version
			memory = MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
			if not memory then return
			memcodes = []

			getLanInject = function
				for el in total
					if el != Target.router.local_ip then return el
				end for
			end function
		
			lan_inject = getLanInject
		
			counter = 1
			for mem in memory
				address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")
		
				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value, lan_inject)


					if result == 1 or result == 0 then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "firewall_disable" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) == "computer" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "computer:bounce" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) == "shell" or typeof(result) == "null" or typeof(result) == "file" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")




					//if typeof(result) != "null" then
						XPLOITS.push([typeof(result), mem, value])
					//end if
					counter = counter + 1
				end for
			end for
		else
			port = pr[option].port_number
			net_session = Current.metaxploit.net_use(Target.address, port)
			if not net_session then return print("Error: can't connect to net session")
			metaLib = net_session.dump_lib
			typeOfCode = metaLib.lib_name + " " + metaLib.version
			memory = MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
			if not memory then return
			memcodes = []

			counter = 1
			for mem in memory
				address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")

				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value)
					if typeof(result) == "number" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "password_change" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) != "number" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					counter = counter + 1
					XPLOITS.push([typeof(result), mem, value])
				end for
			end for
		end if
		
			print("<color=blue>" + "<b>----------------------------------------------------</b>")
		
			num = 0
			while(true)
				option = user_input("Choose a vulnerability:", false, false)
				if option.trim.to_int <= XPLOITS.len and option.trim.to_int >= 1 then
					num = option.trim.to_int - 1
					break
				end if
				if option.trim == "" then return mainFuncs.scan.run(Target.address)
			end while
		
			userInput = user_input("Do you want to pass a IP or a password?:", false, false)
			userInput = userInput.trim
		
			clear_screen()

			Handle ={}
			Handle.shell = function
				shell = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
				Current.shell = shell
				Current.computer = Current.shell.host_computer
				Current.user = MainFuncsForCode.checkuser(shell)

				ismatch = false
				for s in range(Shells.len - 1,0)
					if Shells[s].localIP == shell.host_computer.local_ip and Shells[s].publicIP == shell.host_computer.public_ip then 
						ismatch = true
						break
					end if
				end for
				
				if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

				wasSuccessfull = true

				option = MainFuncsForCode.chosesmth(["1: Enter remotely", "2: Launch kit", "3: Start Terminal"],"Choose a option")
				if option == -1 then return

				if option == 1 then MainFuncsForCode.kit("launch")
				if option == 2 then exit(Current.shell.start_terminal)
				
			end function
			Handle.computer = function
				comp = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				if option == -1 then return
				
				if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(comp)
						if f.type == "d" then print("<color=blue>" + f.name)
						if f.type == "f" then print(" =>" + f.name)
					end for
				end if
				wasSuccessfull = true
			end function
			Handle.file = function
				file = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				if option == -1 then return
				
				if option == 0 then MainFuncsForCode.showAllPasswords(file)
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(file)
						if f.type == "d" then print("<color=blue>" + f.name)
						if f.type == "f" then print(" =>" + f.name)
					end for
				end if
				wasSuccessfull = true
			end function
			Handle.number = function
				res = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
				wasSuccessfull = true
			end function
			Handle.nothing = function
				res = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
				if typeof(res) == "file" then
					file = res
					option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
					if option == -1 then return
					
					if option == 0 then MainFuncsForCode.showAllPasswords(file)
						
					if option == 1 then 
						for f in MainFuncsForCode.getFiles(file)
							if f.type == "d" then print("<color=blue>" + f.name)
							if f.type == "f" then print(" =>" + f.name)
						end for
					end if
					wasSuccessfull = true
				end if
				if typeof(res) == "computer" then
					comp = res
					option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
					if option == -1 then return
					
					if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
						
					if option == 1 then 
						for f in MainFuncsForCode.getFiles(comp)
							if f.type == "d" then print("<color=blue>" + f.name)
							if f.type == "f" then print(" =>" + f.name)
						end for
					end if
					wasSuccessfull = true
				end if
				if typeof(res) == "shell" then 
					shell = res
					Current.shell = shell
					Current.computer = Current.shell.host_computer
					Current.user = MainFuncsForCode.checkuser(shell)
	
					ismatch = false
					for s in range(Shells.len - 1,0)
						if Shells[s].localIP == shell.host_computer.local_ip and Shells[s].publicIP == shell.host_computer.public_ip then 
							ismatch = true
							break
						end if
					end for
					
					if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))
	
					wasSuccessfull = true
				end if
			end function

			if XPLOITS[num][0] == "null" then 
				Handle["nothing"]
			else
				Handle[XPLOITS[num][0]]
			end if

		//if not wasSuccessfull then mainFuncs.scan.run(Target.address)
	end function

	mainFuncs.cleanup = {}
	mainFuncs.cleanup.use = "Usage: cleanup"
	mainFuncs.cleanup.description = "Deletes all files in the folder\nIf the current script is located in kit only /kit will be deleted"
	mainFuncs.cleanup.run = function(x)
		colorPrefixGood = "<color=green>"
		colorPrefixBad = "<color=#FF0000df>"
		emptyRow = "\n" + colorPrefixBad + "<b>-------------------------------------------------------</b>\n"
		withLogClearText = colorPrefixGood + "<b><size=200%>Cleanup completed!</size></b>"

		if not isStartShell(Current.shell) then return print("<color=red>Only possible at host shell\n<color=orange>Note: If the IP is white highlighted")
		currentFolder = Current.computer.File(current_path)
		currentFolderPath = currentFolder.path
		clear_screen()

		if currentFolderPath.split("/")[-1] == "kit" then
			fileName = currentFolder.name
			result = currentFolder.delete
			if result == "" then print(colorPrefixGood + fileName + " got successfully deleted.")
			if result != "" then print(colorPrefixBad + fileName + " " + result)
		else
			for file in currentFolder.get_files
				fileName = file.name
				result = file.delete
				if result == "" then print(colorPrefixGood + fileName + " got successfully deleted.")
				if result != "" then print(colorPrefixBad + fileName + " " + result)
			end for
		end if


		print(emptyRow + withLogClearText + emptyRow)

		mainFuncs.clearlog.run

	end function

	mainFuncs.clearlog = {}
	mainFuncs.clearlog.use = "Usage: clearlog"
	mainFuncs.clearlog.description = "Corrupts log file"
	mainFuncs.clearlog.run = function(x)

		info = "<size=200%>Log cleared</size>"
		emptyRow = "\n<color=#00BBFF><b>-------------------------------------------------------</b>\n"
		file = Current.computer.File("/etc/fstab")

		if file then
			logfile = file.copy("/etc", "log")
			wait(0.02)
			logfile = Current.computer.File("/etc/log")

			if logfile then
				logfile.set_content("deleted")
				logfile.move("/var", "system.log")
			else
				return print("Permissions are lacking to clear logs :()")
			end if
			
			
		else
			return print("Permissions are lacking to clear logs :()")
		end if
		print(emptyRow + info + emptyRow)
	end function

	mainFuncs.sudo = {}
	mainFuncs.sudo.use = "Usage: sudo [user]"
	mainFuncs.sudo.description = "Sudo switches user"
	mainFuncs.sudo.run = function(x)
		if not isStartShell(Current.shell) then return print("<color=red>Only possible at host shell\n<color=orange>Note: If the IP is white highlighted")
		file = ""
		usershell = get_shell(x[0],user_input("Password: ",true,false))
		if not usershell then return print("<color=red>Failed!")
		Current.shell = usershell
		Current.computer = Current.shell.host_computer
		launch(usershell, program_path, "local")
	end function

	mainFuncs.lib = {}
	mainFuncs.lib.use = "Usage: lib"
	mainFuncs.lib.description = "Scan the desired libary for vulnerabilities.\nUse [all] to scan all libs"
	mainFuncs.lib.run = function(x)
		if not isStartShell(Current.shell) then return print("<color=red>Only possible at host shell\n<color=orange>Note: If the IP is white highlighted")

		files = Current.computer.File("/lib").get_files

		if x then
			if x[0] == "all" then return MainFuncsForCode.scanalllibs(files)
		end if

		XPLOITS = []
		libs = []
		lipPaths = []


		for lib in files
			if not lib.name.matches(".so") then continue

			suffix = ""
			if DEBUG then suffix = " [" + lib.has_permission("r") + lib.has_permission("w") + lib.has_permission("x") + "]"

			libs.push(lib.name + suffix)
			lipPaths.push(lib.path)
		end for

		ress = MainFuncsForCode.chosesmth(libs, "Choose a lib")
		if ress == -1 then return

		metaLib = Current.metaxploit.load(lipPaths[ress])
		if not metaLib then 
			if not Current.computer.File(lipPaths[ress]).has_permission("r") then return print("Could not scan " + libs[ress] + "\n<color=red>Reason: No permission!")
			return print("Could not scan " + libs[ress] + "\n<color=red>Reason: Try updating metaxploit!")
		end if


		typeOfCode = metaLib.lib_name + " " + metaLib.version
		memory = MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
		if not memory then return
		memcodes = []
	
		counter = 1
		for mem in memory
			address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")

			if Current.computer.get_name == "router" then
				lan_inject = get_shell.host_computer.local_ip
				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value, lan_inject)
					if result == 1 or result == 0 then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "firewall_disable" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) == "computer" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "computer:bounce" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) == "shell" or typeof(result) == "null" or typeof(result) == "file" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					XPLOITS.push([typeof(result), mem, value])
					counter = counter + 1
				end for
			else
				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value)
					if typeof(result) == "number" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "password_change" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) != "number" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					counter = counter + 1
					XPLOITS.push([typeof(result), mem, value])
				end for
			end if
		end for

		print("<color=blue>" + "<b>----------------------------------------------------</b>")

		num = 0
		while(true)
			option = user_input("Choose a vulnerability:", false, false)
			if option.trim.to_int <= XPLOITS.len and option.trim.to_int >= 1 then
				num = option.trim.to_int - 1
				break
			end if
			if option.trim == "" then return mainFuncs.lib.run
		end while

		userInput = user_input("Do you want to pass a IP or a password?:", false, false)
		userInput = userInput.trim

		clear_screen()

		Handle ={}
		Handle.shell = function
			shell = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
			Current.shell = shell
			Current.computer = Current.shell.host_computer
			Current.user = MainFuncsForCode.checkuser(shell)

			ismatch = false
			for s in range(Shells.len - 1,0)
				if Shells[s].localIP == shell.host_computer.local_ip and Shells[s].publicIP == shell.host_computer.public_ip then 
					ismatch = true
					break
				end if
			end for
			
			if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

			wasSuccessfull = true


			option = MainFuncsForCode.chosesmth(["1: Enter remotely", "2: Launch kit", "3: Start Terminal"],"Choose a option")
			if option == -1 then return

			if option == 1 then MainFuncsForCode.kit("launch")
			if option == 2 then exit(Current.shell.start_terminal)

		end function
		Handle.computer = function
			comp = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
			option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
			if option == -1 then return
			
			if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
				
			if option == 1 then 
				for f in MainFuncsForCode.getFiles(comp)
					if f.type == "d" then print("<color=blue>" + f.name)
					if f.type == "f" then print(" =>" + f.name)
				end for
			end if
			wasSuccessfull = true
		end function
		Handle.file = function
			file = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
			option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
			if option == -1 then return
			
			if option == 0 then MainFuncsForCode.showAllPasswords(file)
				
			if option == 1 then 
				for f in MainFuncsForCode.getFiles(file)
					if f.type == "d" then print("<color=blue>" + f.name)
					if f.type == "f" then print(" =>" + f.name)
				end for
			end if
			wasSuccessfull = true
		end function
		Handle.number = function
			res = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
			wasSuccessfull = true
		end function
		Handle.nothing = function
			res = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
			if typeof(res) == "file" then
				file = res
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				if option == -1 then return
				
				if option == 0 then MainFuncsForCode.showAllPasswords(file)
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(file)
						if f.type == "d" then print("<color=blue>" + f.name)
						if f.type == "f" then print(" =>" + f.name)
					end for
				end if
				wasSuccessfull = true
			end if
			if typeof(res) == "computer" then
				comp = res
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				if option == -1 then return
				
				if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(comp)
						if f.type == "d" then print("<color=blue>" + f.name)
						if f.type == "f" then print(" =>" + f.name)
					end for
				end if
				wasSuccessfull = true
			end if
			if typeof(res) == "shell" then 
				shell = res
				Current.shell = shell
				Current.computer = Current.shell.host_computer
				Current.user = MainFuncsForCode.checkuser(shell)

				ismatch = false
				for s in range(Shells.len - 1,0)
					if Shells[s].localIP == shell.host_computer.local_ip and Shells[s].publicIP == shell.host_computer.public_ip then 
						ismatch = true
						break
					end if
				end for
				
				if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

				wasSuccessfull = true
			end if
		end function

		if XPLOITS[num][0] == "null" then 
			Handle["nothing"]
		else
			Handle[XPLOITS[num][0]]
		end if
	end function

	mainFuncs.kit = {}
	mainFuncs.kit.use = "Usage: kit"
	mainFuncs.kit.description = "Create kit for local use on target system"
	mainFuncs.kit.run = function(x)
		MainFuncsForCode.kit("install")
	end function

	mainFuncs.tree = {}
	mainFuncs.tree.use = "Usage: tree"
	mainFuncs.tree.description = "Shows all folders and files plus permissions"
	mainFuncs.tree.run = function(x)
		clear_screen
		output = ""
		print("<color=#96B800>========================")
		for f in MainFuncsForCode.getFiles(Current.shell)
			if f.type == "d" then output = output + "<color=#AD0C00>" + f.object.permissions + " <color=blue>" + f.name + "\n"
			if f.type == "f" then output = output + "<color=#AD0C00>" + f.object.permissions + "<color=#B18700>" + "  =>" + f.name + "\n"
		end for
		print(output)
		print("<color=#96B800>========================")
	end function

	mainFuncs.shell = {}
	mainFuncs.shell.use = "Usage: shell [show/s/rn]"
	mainFuncs.shell.description = "Use [show] to show the log of shells\nUse [s] + index to connect to desired shell\nUse [rn] to rename a shell"
	mainFuncs.shell.run = function(x)
		if x == null then return print(mainFuncs.shell.use)

		PrintAllShells = function
			for e in range(0, Shells.len - 1)
				print("<color=#00CCFF>--------------------------")
				if e == 0 then print("StartShell")
				if e != 0 then print(Shells[e].name + " " + e)
				suffix = ""
				if Shells[e].localIP == Current.computer.local_ip and Shells[e].publicIP == Current.computer.public_ip then suffix = " <color=#8F7900>[Current]"
				print("User: " + MainFuncsForCode.checkuser(Shells[e].shell) + suffix)
				print("Public IP: " + Shells[e].publicIP)
				print("Local IP: " + Shells[e].localIP)
			end for
			print("<color=#00CCFF>--------------------------")
		end function

		if x[0] == "show" then
			PrintAllShells()
		end if

		if x[0] == "cleanup" then
			colorPrefixGood = "<color=green>"
			colorPrefixBad = "<color=#FF0000df>"
			emptyRow = "\n" + colorPrefixBad + "<b>-------------------------------------------------------</b>\n"
			withLogClearText = colorPrefixGood + "<b><size=200%>Cleanup completed!</size></b>"
	
			if Shells.len - 1 == 0 then return print("There are no shells to clean")

			for e in range(1,Shells.len - 1)	
				print(Shells[e].name + e + ":")
				shell = Shells[e].shell
				path = null
				for file in MainFuncsForCode.getFiles(shell)
					if file.name == "kit" then path = file.path
				end for

				if not path and DEBUG then
					print("No kit found")
				else if path then 
					kit = shell.host_computer.File(path)
					result = kit.delete

					if not kit then
						if DEBUG then return print(Shells[e].name + e + ": " + colorPrefixGood + kit.name + " not found.")
						return
					end if

					if result == "" then print(colorPrefixGood + "Kit got successfully deleted.")
					if result != "" then print(colorPrefixBad + "Kit could not be deleted " + result)

				end if

				info = "<size=200%>Log cleared</size>"
				emptyRow = "\n<color=#00BBFF><b>-------------------------------------------------------</b>\n"
				file = Shells[e].shell.host_computer.File("/etc/fstab")

				if file then
					logfile = file.copy("/etc", "log")
					wait(0.02)
					logfile = Shells[e].shell.host_computer.File("/etc/log")

					if logfile then
						logfile.set_content("deleted")
						logfile.move("/var", "system.log")
					else
						return print("Permissions are lacking to clear logs :()")
					end if
					
					
				else
					return print("Permissions are lacking to clear logs :()")
				end if
			end for

			print(emptyRow + withLogClearText + emptyRow)

		end if

		if x[0] == "s" then
			if x.len < 2 then return PrintAllShells
			if x[1].to_int < Shells.len and x[1].to_int >= 1 then

				print("<color=#00B7FF>--------------------------------------")
				print("Routing to " + Shells[x[1].to_int].name + " " + x[1] + "\nUser: " + MainFuncsForCode.checkuser(Shells[x[1].to_int].shell) + "\nPublic IP: " +  Shells[x[1].to_int].publicIP + "\nLocal IP: " + Shells[x[1].to_int].localIP)
				print("<color=#00B7FF>--------------------------------------")

				//HANDLE SHELL
				shell = Shells[x[1].to_int].shell
				Current.shell = shell
				Current.computer = Current.shell.host_computer
				Current.user = MainFuncsForCode.checkuser(shell)

				option = MainFuncsForCode.chosesmth(["1: Enter remotely", "2: Launch kit", "3: Start Terminal"],"Choose a option")
				if option == -1 then return
	
				if option == 1 then MainFuncsForCode.kit("launch")
				if option == 2 then exit(Current.shell.start_terminal)
				//HANDLE SHELL
			else 
				print("Shell " + x[1] + " does not exist")
			end if
		end if

		if x[0] == "rn" then 
			PrintAllShells()
			if Shells.len <= 1 then return print("There are no shells to rename.")
			while (true)
				num = user_input("<size=80%>" + "<color=red>TEST " + "</color>" + "</size>" + "<pos=0%><voffset=-1.2em>" + "[" + Current.user + "@" + Current.computer.get_name  + "] </color>sel.:").trim
				if num.trim == "" then continue
				if num.to_int < Shells.len and num.to_int >= 1 then 
					while (true)
						userChoice = user_input("<size=80%>" + "<color=red>TEST " + "</color>" + "</size>" + "<pos=0%><voffset=-1.2em>" + "[" + Current.user + "@" + Current.computer.get_name  + "] </color>name.:").trim
						if userChoice.trim == "" then continue
						Shells[num.to_int].setName(userChoice)
						break
					end while
				end if
				break
			end while

			print("Shell " + num + " renamed to " + userChoice)
		end if
	end function

	mainFuncs.update = {}
	mainFuncs.update.use = "Usage: update"
	mainFuncs.update.description = "Updates apt client and upgrades if needed"
	mainFuncs.update.run = function(x)
		result = Current.aptclient.update()
		if result == "" then
			print("Updating aptclient was succsessful!")
		else
			return print("Updating aptclient failed: " + result)
		end if

		print("Installing metaxploit.so")
		Current.aptclient.install("metaxploit.so", current_path)
		Current.metaxploit = include_lib(current_path + "/metaxploit.so")
	
		print("Installing crypto.so")
		Current.aptclient.install("crypto.so", current_path)
		Current.crypt = include_lib(current_path + "/crypto.so")
	end function

	mainFuncs.lock = {}
	mainFuncs.lock.use = "Usage: lock"
	mainFuncs.lock.description = "Locks all files and executeables except Terminal.exe and the sudo cmd\nUse [-] to unlock all\nUse [all] to lock everything for every user"
	mainFuncs.lock.run = function(x)

		if x then
			if x[0] == "-" then 
				if not Current.computer.File("/").has_permission("w") then return print("<color=red>You have no permission to do that!")
				allFiles = MainFuncsForCode.getFiles(Current.shell)
				for file in allFiles
					file.object.chmod("u+wrx")
					file.object.chmod("o+wrx")
					file.object.chmod("g+wrx")
				end for
				print("<color=yellow>=================================================")
				print("<size=200%><color=blue>System unlocked!")
				print("<color=yellow>=================================================")
				return
			else if x[0] == "all" then


				while true
					userinput = user_input("This command will lock all users\nDo you want to proceed y/n\n", false, true).trim
					if userinput == "y" or userinput == "Y" then break
					return print("Process interrupted.")
				end while

				while true
					userinput = user_input("Enter password: ", true).trim
					if userinput == "" and password != "" then return print("Process interrupted.")
					if userinput != password and userinput != "" then continue
					break
				end while

				if not Current.computer.File("/").has_permission("w") then return print("<color=red>You have no permission to do that!")
				allFiles = MainFuncsForCode.getFiles(Current.shell)
				for file in allFiles
					file.object.chmod("u-wrx")
					file.object.chmod("o-wrx")
					file.object.chmod("g-wrx")
				end for
		
				print("<color=yellow>=================================================")
				print("<size=200%><color=blue>System locked!")
				print("<color=yellow>=================================================")
			end if
		else
			if not Current.computer.File("/").has_permission("w") then return print("<color=red>You have no permission to do that!")
			allFiles = MainFuncsForCode.getFiles(Current.shell)
			for file in allFiles
				if file.name == "passwd" or file.name == "Mail.txt" then 
					file.object.delete
					print(file.name + " got deleted")
					continue
				end if
				if file.name.matches("sudo") or file.name.matches("Terminal.exe") or file.name.matches("Terminal") then continue
				file.object.chmod("o-wrx")
				file.object.chmod("g-wrx")
			end for
	
			print("<color=yellow>=================================================")
			print("<size=200%><color=blue>System locked!")
			print("<color=yellow>=================================================")
		end if



	end function

	mainFuncs.q = {}
	mainFuncs.q.use = "Usage: q"
	mainFuncs.q.description = "Exits out of test script"
	mainFuncs.q.run = function(x)

		while true
			userinput = user_input("Sure you want to quit? [y/n]\n", false, true).trim.lower
			if userinput == "y" then 
				clear_screen
				exit("Shutting down...")
			end if
			if userinput == "n" then break
		end while
	end function

	mainFuncs.ps = {}
	mainFuncs.ps.use = "Usage: ps"
	mainFuncs.ps.description = "Displays running processes"
	mainFuncs.ps.run = function(x)
		allProcs = Current.computer.show_procs
		allProcs = allProcs.replace("ps", "<color=red>rshell</color>")

		print(format_columns(allProcs))
	end function

	mainFuncs.kill = {}
	mainFuncs.kill.use = "Usage: kill <color=orange>PID</color>"
	mainFuncs.kill.description = "Kills running process "
	mainFuncs.kill.run = function(x)
		if not x then return print("<color=red>Invalid PID\nUse: kill <color=orange>PID</color> ")
		PID = x[0].to_int
		if typeof(PID) != "number" then return print("<color=red>The PID must be a number")
		
		output = Current.computer.close_program(PID)
		if output == true then return print("Process " + PID + " closed");
		if output then return print("<color=red>" + output)
		print("<color=red>Process " + "<color=orange>" + PID + "</color> not found")
	end function

	mainFuncs.rshell = {}
	mainFuncs.rshell.use = "Usage: rshell"
	mainFuncs.rshell.description = "Runs rshell interface"
	mainFuncs.rshell.run = function(x)

		if x[0] == "-i" or x[0] == "install" then
			librs = include_lib("/lib/librshell.so")
			if not librs then librs = include_lib(current_path + "/librshell.so")

			if not librs then 
				print("Installing librshell.so")
				Current.aptclient.install("librshell.so", "/lib")
			end if

			librs = include_lib("/lib/librshell.so")

			out = librs.install_service
			if not out then
				print(out)
				return
			end if
			print("<b>Type 'Browser.exe " + get_router.local_ip + ":8080' to access the router configuration to make sure the service it's accessible</b>")
		end if

		if x[0] == "start" then
			librs = include_lib("/lib/librshell.so")
			if not librs then librs = include_lib(current_path + "/librshell.so")
			if not librs then 
				print("librshell.so is not installed\nUse rshell [-i/install] to install Service")
				return
			end if

			rc = librs.start_service

			if typeof(rc) == "string" then return print("Error: " + rc) else print("Rshell service successfully started")
		end if

		if x[0] == "stop" then
			librs = include_lib("/lib/librshell.so")
			if not librs then librs = include_lib(current_path + "/librshell.so")
			if not librs then 
				print("librshell.so is not installed\nUse rshell [-i/install] to install Service")
				return
			end if

			rc = librs.stop_service

			if typeof(rc) == "string" then return print("Error: " + rc) else print("Rshell service successfully stopped")
		end if

		if x[0] == "run" then
			if not isStartShell(Current.shell) then return print("<color=red>Only possible at host shell\n<color=orange>Note: If the IP is white highlighted")
			input = user_input("Choose a Port:", false, false).trim.to_int
			print("<color=blue>=================</color>")
			if typeof(input) != "number" then 
				if input != "" then print("<color=red>Wrong Syntax</color>")
				print("<color=orange>Port defaulted to 1000</color>")
				input = 1000
			else
				print("Port: " + input)
			end if


			res = Current.metaxploit.rshell_client(Shells[0].publicIP, input, "ps")
			if res then print("Success") else print("Failed")
			print("<color=blue>=================</color>")
		end if

		if not x then
			shells = Current.metaxploit.rshell_server

			if typeof(shells) == "string" then
				print(shells)
				return
			end if

			if shells.len < 1 then 
				print("There are no shells connected!")
				return
			end if

			option = 0
			while typeof(option) != "number" or (option < 1 or option > shells.len)
				print(shells.len + " shell(s) connected!\n<b>Select a shell to start a terminal:</b>")
				for i in range(0, shells.len - 1)
					print("\n<b>Shell (" + (i + 1) + ")</b>\nPublic IP: " + shells[i].host_computer.public_ip + "\nLocal IP: " + shells[i].host_computer.local_ip)
				end for
				print("-----------")
				option = user_input("Select shell>").to_int
			end while
			print("Starting shell #" + option)
			
			//HANDLE SHELL
			shell = shells[option - 1]
			Current.shell = shell
			Current.computer = Current.shell.host_computer
			Current.user = MainFuncsForCode.checkuser(shell)

			ismatch = false
			for s in range(Shells.len - 1,0)
				if Shells[s].localIP == shell.host_computer.local_ip and Shells[s].publicIP == shell.host_computer.public_ip then 
					ismatch = true
					break
				end if
			end for
			
			if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

			option = MainFuncsForCode.chosesmth(["1: Enter remotely", "2: Launch kit", "3: Start Terminal"],"Choose a option")
			if option == -1 then return

			if option == 1 then MainFuncsForCode.kit("launch")
			if option == 2 then exit(Current.shell.start_terminal)
			//HANDLE SHELL

		end if

	end function
	
	mainFuncs.fx = {}
	mainFuncs.fx.use = "Usage: fx"
	mainFuncs.fx.description = "Runs fileexplorer"
	mainFuncs.fx.run = function(x)
		num = 0
		depth = 0
		showPerms = false
		prev = []
		markPrefix = "<mark=#D1D1D143>"

		mainfolder = Current.computer.File("/")
		cont = mainfolder.get_files + mainfolder.get_folders
		clear_screen

		while (true)

			counter = 0
			clear_screen()
			print ("<color=red>X</color>plorer")
			print("<color=blue>===========================================")
			for variables in cont

				if showPerms then
					if counter == num then print(markPrefix + variables.name + "</mark>                          " + variables.permissions)
					if counter != num then print(variables.name + "                          " + variables.permissions)
				else
					if counter == num then print(markPrefix + variables.name)
					if counter != num then print(variables.name)
				end if



				counter = counter + 1
			end for
			if not cont then print("<color=orange>EMPTY")
			print("<color=blue>===========================================")

			desc = "             <rotate=90>>   </rotate>      W" + char(10) + "          <  <rotate=-90>>  </rotate>>   A  S  D" + char(10) + char(10) +
			"1 - Download file/folder" + char(10) +
			"2 - toggle permissions" +
			"<size=0%>"

			key = user_input(desc, false, true)

			if (key == "DownArrow") or (key == "s") then
				num = num + 1
				if num > cont.len - 1 then num = 0
			else if (key == "UpArrow") or (key == "w") then
				num = num - 1
				if num < 0 then num = cont.len - 1
			else if (key == "RightArrow") or (key == "d") then
				if not cont then continue
				if not cont[num].is_folder then 
					res = cont[num].get_content
					if typeof(res) == "string" then 
						clear_screen
						print ("<color=red>X</color>plorer")
						print("<color=blue>===========================================")
						print(cont[num].name)
						print(char(10) + res)
						print("<color=blue>===========================================")

						user_input("Press any button to return<size=0%>", false, true)
					end if
				end if
				if cont[num].is_folder then 
					prev.push(cont)
					depth = depth + 1
					cont = cont[num].get_files + cont[num].get_folders
					num = 0
				end if
			else if ((key == "LeftArrow") or (key == "a")) and depth != 0 then
				depth = depth - 1
				if depth < 0 then depth = 0

				cont = prev[depth]
				prev.remove(depth)
			else if key == "1" then
				destFolder = "/home/guest/Downloads"
				if has_permission(Shells[0].shell.host_computer.File("/"), "w") then destFolder = "/root/Downloads"

				clear_screen
				print("Starting download of " + cont[num].name + "...")
				res = Current.shell.scp(cont[num].path, destFolder, Shells[0].shell)
				if res == 1 then 
					print("Successfully sent file to hostmachine")
					print("--> " + destFolder)
				end if
				if typeof(res) == "string" then print("<color=red>Error: " + res)

				print("<color=blue>===========================================")
				user_input("Press any button to return<size=0%>", false, true)

			else if key == "q" then 
				clear_screen
				break
			end if

		
		end while


	end function

	mainFuncs.rnd = {}
	mainFuncs.rnd.use = "Usage: rnd"
	mainFuncs.rnd.description = "Get a random IP"
	mainFuncs.rnd.run = function(x)
		print(MainFuncsForCode.rndIp)
	end function

	mainFuncs.pw = {}
	mainFuncs.pw.use = "Usage: pw"
	mainFuncs.pw.description = "Get passwords from current os\nMight not show all pw on lower priviliges then root"
	mainFuncs.pw.run = function(x)
	 	clear_screen
		print(MainFuncsForCode.showAllPasswords(Current.computer.File("/")))
	end function

	mainFuncs.clear = {}
	mainFuncs.clear.use = "Usage: clear"
	mainFuncs.clear.description = "Clears screen"
	mainFuncs.clear.run = function(x)
	 	clear_screen
	end function

	mainFuncs.dec = {}
	mainFuncs.dec.use = "Usage: dec [user@password]"
	mainFuncs.dec.description = "Deciphers password"
	mainFuncs.dec.run = function(x)
		if not x then return print(mainFuncs.dec.use)
		MainFuncsForCode.PrintPassword(x[0])
	end function

	x = new self
	x.cmd = mainFuncs
	return x

end function

Menu.help = function
	lineColor = "<color=#004A9F>"
	print(lineColor + "------------------------------------------------------</color>")
	for each in self.cmd.indexes
		if self.cmd[each].hasIndex("run") and self.cmd[each].hasIndex("description") then print(self.cmd[each].use + "\n" + self.cmd[each].description + "\n" + lineColor + "------------------------------------------------------</color>")
	end for
end function

Menu.CommandHandler = function(command)
	command = command.split(" ")

	for a in range(command.len - 1)
		if command[a] == "" then command.remove(command.indexOf(""))
	end for

	if self.cmd.hasIndex(command[0].lower) then 
		f = @self.cmd[command[0].lower].run
		if command.len > 1 then f(command[1:]) else f
	else
		print("<color=red>Invalid command!")
	end if

end function

Menu.run = function
	while (true)
		if not get_shell.host_computer.is_network_active then ipText = "<color=red><b>OFFLINE</b></color>" else ipText = Current.computer.local_ip + ":" + Current.computer.public_ip
	
		color = "<color=red>"
		if isStartShell(Current.shell) then color = "<color=white>"

		userChoice = user_input("<size=80%>" + color + "TEST" + "[" + ipText + "]" + "</color>" + "</size>" + "<pos=0%><voffset=-1.2em>" + Current.user + "@" + Current.computer.get_name  + ":" + program_path + "> </color>").trim
		// userChoice = user_input("<size=80%>" + "<color=red>TEST " + suffix + "</color>" + "</size>" + "<pos=0%><voffset=-1.2em>" + "[" + Current.user + "@" + Current.computer.get_name  + "] </color>").trim
		if userChoice == "" then continue
		if userChoice == "-h" or userChoice == "help" then
			self.help
			continue
		end if
		self.CommandHandler(userChoice)
	end while
end function

menu = Menu.init
menu.run