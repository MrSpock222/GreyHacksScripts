__version = "2.0"
__name = "test"

/////////////////////////////////////////////////////////CONFIG START/////////////////////////////////////////////////////////
password = "cola123"
hackshopip = "93.75.162.58" //If not set use apt-get
codesFileName = "codes.db" //
codesPath = "/root"
Server = {}
Server.use = false
Server.IP = "78.194.123.64"
Server.port = "22"
Server.service = "ssh"
Server.pw = "love666"
Server.user = "root"
/////////////////////////////////////////////////////////CONFIG END/////////////////////////////////////////////////////////
Server.shell = null //DONT CHANGE

Target = {}
Target.router = null
Target.address = ""
Target.prevaddress = ""
Target.files = {}
Target.firewalls = {}
Target.firewalls.rules = []
Target.firewalls.ips =[]
Target.passwords = ""
Target.mails = ""

Current = {}
Current.shell = get_shell
Current.computer = Current.shell.host_computer
Current.user = active_user
Current.metaxploit = null
Current.aptclient = null
Current.crypt = null
wasSuccessfull = false

DEBUG = true
if DEBUG then
	Current.metaxploit = include_lib("/lib/metaxploit.so")
	Current.crypt = include_lib("/lib/crypto.so")
	Current.aptclient = include_lib("/lib/aptclient.so")
	global.metaxlibs.push(Current.metaxploit)
end if

Shells = []
Shell = {}
Shell.shell = null
Shell.localIP = ""
Shell.publicIP = ""
Shell.name = ""
Shell.getPublicIP = function
	return self.publicIP
end function
Shell.getLocalIP = function
	return self.localIP
end function
Shell.getShell = function
	return self.shell
end function
Shell.setName = function(name)
	self.name = name
end function
Shell.create = function(shell, publicIP, localIP, name = "Shell")
	x = new Shell
	x.shell = shell
	x.localIP = localIP
	x.publicIP = publicIP
	x.name = name
	return x
end function

Shells.push(Shell.create(Current.shell,Current.computer.public_ip,Current.computer.local_ip))

File = {}
File.object = null
File.name = ""
File.path = ""
File.type = ""
File.content = ""
File.getName = function
	return self.name
end function

File.getPath = function
	return self.path
end function

File.getType = function
	return self.type
end function

File.getContent = function
	return self.content
end function

File.getObject = function
	return self.object
end function

File.create = function(name, path, type, content, object)
	x = new File
	x.name = name
	x.path = path
	x.type = type
	x.content = contents
	x.object = object
	return x
end function

list.get = function(x)
	for e in self
		if e == x then return e
	end for
	return null
end function

MainFuncsForCode = {}
MainFuncsForCode.chosesmth = function(listOfVariables = ["option 1"], descriptionText = "No description set", removeInt = 0, showInfo = false, printDescription = false)
	markPrefix = "<mark=#D1D1D143>"
	infoPrefix = "<color=#FF0000df>"
	num = 0
	if showInfo then router = Target.router
	if removeInt > 0 then listOfVariables.remove(removeInt - 1)
	
		while (true)
		counter = 0
		clear_screen()
		print (descriptionText)
		
		print("-------------------------------------------")
		for variables in listOfVariables
			if false then //////////////////////DEBUG///////////////////////////
				if counter == num then print(markPrefix + variables + " " + num)
				if counter != num then print(variables + " " + num)
				counter = counter + 1
			else
				if counter == num then print(markPrefix + variables)
				if counter != num then print(variables)
				counter = counter + 1
			end if
		end for
		print("-------------------------------------------")

		key = user_input("Press Up or Down arrow Key", false, true)

		if (key == "DownArrow") or (key == "s") then
			num = num + 1
			if num > listOfVariables.len - 1 then num = 0
		else if (key == "UpArrow") or (key == "w") then
			num = num - 1
			if num < 0 then num = listOfVariables.len - 1
		else
			clear_screen()
			print("You chose: " + (num + 1))
			return num
		end if
		
		end while
	
end function

MainFuncsForCode.getmemcodes = function(typeOfCode, metaLib)
	memory = null

	if DEBUG then return Current.metaxploit.scan(metaLib)

	if Server.use then
		if Server.shell.host_computer.File(codesPath + "/" + codesFileName) == null then
			hostComputer = Server.shell.host_computer
			createResult = hostComputer.touch(codesPath, codesFileName)
			if typeof(createResult) == "number" then
				print("[SERVER] Codes file got created at given path " + codesPath)
			else if typeof(createResult) == "string" then
				print("[SERVER] " + createResult)
			end if
		end if
	else
		if get_shell.host_computer.File(codesPath + "/" + codesFileName) == null then
			hostComputer = get_shell.host_computer
			createResult = hostComputer.touch(codesPath, codesFileName)
			if typeof(createResult) == "number" then
				print("[LOCAL] Codes file got created at given path " + codesPath)
			else if typeof(createResult) == "string" then
				print("[LOCAL] " + createResult)
			end if
		end if
	end if

	if not Server.use then codesFile = get_shell.host_computer.File(codesPath + "/" + codesFileName)
	if Server.use then codesFile = Server.shell.host_computer.File(codesPath + "/" + codesFileName)

	if codesFile == null then print("codes.txt doesnt exist at path: " + codesPath) //ONLY FOR DEBUG REASONS.. SHOULD ALREADY BE CREATED IF NOT EXISTING

	codeCont = codesFile.get_content.split(":")

	for line in codeCont
		if line == "" then break
		le = line.split(" ")
		if le[0] + " " + le[1] != typeOfCode then continue
		memory = line[line.indexOf("[") : line.indexOf(":")]
		memory = memory.split("""")
		break
	end for

	if memory == null then
		memory = Current.metaxploit.scan(metaLib)
		if memory == null then exit("Update your metaxploit.so libary!")
		toWriteMem = " " + memory

		if Server.use then Server.shell.host_computer.File(codesPath + "/" + codesFileName).set_content(Server.shell.host_computer.File(codesPath + "/" + codesFileName).get_content + typeOfCode + toWriteMem + ":")
		if not Server.use then get_shell.host_computer.File(codesPath + "/" + codesFileName).set_content(get_shell.host_computer.File(codesPath + "/" + codesFileName).get_content + typeOfCode + toWriteMem + ":")
	end if

	return memory
end function

MainFuncsForCode.showAllPasswords = function(file)

	while file.path != "/"
		file = file.parent
	end while

	if not file then return print(file.name + " not found.")
	holderPass = []
	holderMail = []
	holderAll = []
	for f in MainFuncsForCode.getFiles(file)
		if f.getContent == null then continue
		if f.getName == "passwd" and f.getContent != "" then 
			for a in f.getContent.split("\n")
				if a != "" and holderPass.indexOf(a) == null then holderPass.push(a)
			end for
		end if

		if f.getName == "Mail.txt" and f.getContent != "" then 
			for a in f.getContent.split("\n")
				if a != "" and holderMail.indexOf(a) == null then holderMail.push(a)
			end for
		end if

		if (f.getName == "Mail.txt" or f.getName == "passwd") and f.getContent != "" then 
			for a in f.getContent.split("\n")
				if a != "" and holderAll.indexOf(a) == null then holderAll.push(a)
			end for
		end if
	end for

	counter = 1
	print("Passwords:")
	if holderPass.len == 0 then
		print("No credentials found.")
	else
		for f in holderPass
			if not f then continue
			print(counter + ": " + f)
			counter = counter + 1
		end for
	end if 

	print("Mails:")
	if holderMail.len == 0 then
		print("No credentials found.")
	else
		for f in holderMail
			if not f then continue
			print(counter + ": " + f)
			counter = counter + 1
		end for
	end if 

	if holderAll.len == 0 then return user_input("Nothing found :(")

	while true
		option = user_input("Choose: ")
		if (option.trim.to_int > counter or counter <= option.trim.to_int) and not option.trim == "all" then continue 

		if option == "" then
			return
		else if option == "all" then
			for a in range(0,holderAll.len - 1)
				MainFuncsForCode.PrintPassword(holderAll[a])
			end for
		else if option == "allp" then
			for a in range(0,holderPass.len - 1)
				MainFuncsForCode.PrintPassword(holderPass[a])
			end for
		else if option == "allm" then
			for a in range(0,holderMail.len - 1)
				MainFuncsForCode.PrintPassword(holderMail[a])
			end for
		else
			MainFuncsForCode.PrintPassword(holderAll[option.to_int - 1])
		end if
		break
	end while
end function

MainFuncsForCode.getFiles = function(targetShell = null, x = "", excludeFolder = "")
	
	if typeof(targetShell) == "shell" then f = host_computer(targetShell).File("/")
	if typeof(targetShell) == "computer" then f = targetShell.File("/")
	if typeof(targetShell) == "file" then 
		f = targetShell
		while f.path != "/"
			f = f.parent
		end while
	end if
	x = x.trim
	if x.len > 3 then return null
	Files = []

	RecFunc = function(f)
		for fil in f.get_folders
			
			if x == "" then
				Files.push(File.create(fil.name, fil.path,"d","",fil))
			else
				if fil.name == excludeFolder then continue

				hasperm = true
				for perm in range(x)
					if not fil.has_permission(x[perm]) then 
						hasperm = false
						continue
					end if
				end for

				if hasperm then 
					Files.push(File.create(fil.name, fil.path,"d","", fil))
				end if

			end if

			for fe in fil.get_files

				if x == "" then
					Files.push(File.create(fe.name, fe.path,"f",fe.get_content, fe))
				else

					if fe.name == excludeFolder then continue	
	
					hasperm = true
					for perm in range(x)
						if not fe.has_permission(x[perm]) then
							hasperm = false
							continue
						end if
					end for
	
	
					if hasperm then 
						Files.push(File.create(fe.name, fe.path,"f",fe.get_content, fe))
					end if
				end if

			end for
			RecFunc(fil)
		end for
	end function

	RecFunc(f)
	
	return Files

end function

MainFuncsForCode.PrintPassword = function(line)

	userPass = line.split(":")
	if userPass.len != 2 then return ("decipher: wrong syntax")
	password = Current.crypt.decipher(userPass[1])
	if not password then print("Can't find password :(")
	if password then 
		get_custom_object["succeeded"] = true
		print("\nUser: " + userPass[0])
		print("Password: " + "<color=red>" + password)
	end if

end function

MainFuncsForCode.scanalllibs = function()

	for lib in Current.computer.File("/lib").get_files
		metaLib = Current.metaxploit.load(lib.path)
		if not metaLib then 
			print("Could not scan " + lib.name + "\n<color=red>Update metaxploit!")
			continue
		end if
		typeOfCode = metaLib.lib_name + " " + metaLib.version
		print("Scanning: " + metaLib.lib_name + " " + metaLib.version)
		MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
	end for

	// libs = []
	// lipPaths = []

	// for file in Current.computer.File("/lib").get_files
	// 	libs.push(file.name)
	// 	lipPaths.push(file.path)
	// end for

	// ress = MainFuncsForCode.chosesmth(libs, "Choose a lib")
	// metaLib = Current.metaxploit.load(lipPaths[ress])
	// typeOfCode = metaLib.lib_name + " " + metaLib.version
	// print("Scanning: " + metaLib.lib_name + " " + metaLib.version)
	// MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
end function

MainFuncsForCode.checkuser = function(result)
	user = ""
	rfile = null
	file = null
	if typeof(result) != "shell" and typeof(result) != "file" and typeof(result) != "computer" then return "???"
	if typeof(result) == "computer" then
		file = result.File("/home")
		rfile = result.File("/root")
	else if typeof(result) == "shell" or typeof(result) == "ftpshell" then
		file = result.host_computer.File("/home")
		rfile = result.host_computer.File("/")
	end if
	if rfile and rfile.has_permission("w") then
		user = "root"
	else if rfile and file then
		for folder in file.get_folders
			if folder.has_permission("w") and folder.name != "guest" then user = folder.name
		end for
	end if


	if typeof(result) == "file" then
	file = result
	if file.name != "/" then
		file = file.parent
		while file.name != "/"
			file = file.parent
		end while
	end if

	if not file then return "???"
	if file.has_permission("w") then user = "root"
		for folder in file.get_folders
			if folder.name == "root" then
				if folder.has_permission("w") then user = "root"
			end if
			if folder.name == "home" and user != "root" then
				for sub in folder.get_folders
					if sub.has_permission("w") and sub.name != "guest" then user = sub.name
				end for
			end if
		end for
	end if
	if user == "" then user = "guest"
	return user
end function

MainFuncsForCode.copytotarget = function(targetShell)

	paths = []

	for folder in MainFuncsForCode.getFiles(targetShell, "wrx")
		if folder.getType == "d" then paths.push(folder.getPath)
	end for

	loc = paths.get("/root")
	if not loc then loc = paths.get("/home/" + MainFuncsForCode.checkuser(targetShell))

	kit = Shells[0].getShell.host_computer.File(current_path + "/kit")
	kit.chmod("o+wrx")
	if not kit then return print("Test kit is missing")

	print("Installing test-kit on target...")

	res = Shells[0].getShell.scp(kit.path,loc, targetShell)
	if res == "string" then print("Error: " + res)

	return loc + "/kit/" + launch_path.split("/")[-1]
end function

// info = "[" + Current.computer.public_ip + ":" + Current.computer.local_ip + "]"

Menu = {}
Menu.init = function()


	if password != "" then
		while(true)
			if user_input("<size=80%>" + "<color=red>TEST" + "</size>" + "<pos=0%><voffset=-1.2em>" + "Password: " + "</color>",true).trim == password then break
			clear_screen
			print("<color=red><b>Wrong password</b>")
		end while
	end if

	clear_screen()
	print "\n<align=""center"">Hacking Tool" + char(169) + "</align>\n<align=""center""><size=50px>TEST</size></align>\n<align=""center"">" + "by" + " Notschge</align>\n"
	print "Initializing..."

	if not DEBUG then
		if Server.use then Server.shell = get_shell.connect_service(Server.IP, Server.port, Server.user, Server.pw, Server.service)
		if typeof(Server.shell) != "shell" and Server.use then return print("Server connection failed...\nCheck configs")
	
		Current.aptclient = include_lib("/lib/aptclient.so")
		if not Current.aptclient then Current.aptclient = include_lib(current_path + "/aptclient.so")
		if not Current.aptclient then exit("There is no aptclient.so at " + current_path + " or /lib")
		Current.aptclient.add_repo(hackshopip)
		Current.aptclient.update()
	
		if Current.aptclient.search("metaxploit.so").is_match("not found") then 
			exit("Add hackshop in sources or with apt-get addrepo [$HACKSHOP_IP]")
		end if
	
		print("Installing metaxploit.so")
		Current.aptclient.install("metaxploit.so", current_path)
		Current.metaxploit = include_lib(current_path + "/metaxploit.so")
		global.metaxlibs.push(Current.metaxploit)
	
		print("Installing crypto.so")
		Current.aptclient.install("crypto.so", current_path)
		Current.crypt = include_lib(current_path + "/crypto.so")
		if params then
			if params[0] == "dolocalkitstuff" then exit()
		end if
	end if

	mainFuncs = {}
	mainFuncs.scan = {}
	mainFuncs.scan.use = "Usage: scan [IPADDRESS]"
	mainFuncs.scan.description = "Scan for ports at desired IP"
	mainFuncs.scan.run = function(x)
		XPLOITS = []
		wasSuccessfull = false
		portIndex = 1
		portInfo = "PORTINDEX PORT STATUS SERVICE INFO LAN\n"
		allLanDevices = ""
		ports = null
		pr = []

		if not x then 
			if not Target.prevaddress then return print(mainFuncs.scan.use)
			Target.address = Target.prevaddress
		else
			if x[0] == "-r" then Target.address = get_router
			if not is_valid_ip(x[0]) then 
				Target.address = Target.prevaddress
			else
				Target.address = x[0]
				Target.prevaddress = Target.address
			end if
		end if

		////////////////////MAIN SETUP////////////////////

		isLanIp = is_lan_ip(Target.address)


		if isLanIp then
			Target.router = get_router
		else
			Target.router = get_router( Target.address )
		end if

		if Target.router == null then return print("nmap: ip address not found")

		if not isLanIp then
			ports = Target.router.used_ports
		else
			ports = Target.router.device_ports(Target.address)
		end if

		if ports == null then return print("nmap: ip address not found")

		if typeof(ports) == "string" then return print(ports)
		

		//PUSH ROUTER TO ADDRESS LIST
		service_info = Target.router.kernel_version
		portInfo = portInfo + portIndex + " " + Target.router.public_ip + " " + "gateway" + " " + "router" + " " + service_info + " " + Target.router.local_ip + "\n"
		pr.push(0)
		portIndex = portIndex + 1
		//PUSH ROUTER TO ADDRESS LIST

		for port in ports
			service_info = Target.router.port_info(port)
			lan_ips = port.get_lan_ip
			port_status = "open"

			if(port.is_closed and not isLanIp) then
				port_status = "closed"
			end if

			if lan_ips == Target.router.local_ip then continue
			portInfo = portInfo + portIndex + " " + port.port_number + " " + port_status + " " + service_info + " " + lan_ips + "\n"
			pr.push(port)
			portIndex = portIndex + 1
		end for

		Target.firewalls.ips = []
		Target.firewalls.rules = []
		hold = []
		total = []

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NEEEDSS WOOORKS//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		for el in Target.router.devices_lan_ip
			total.push(el)
		end for

		Target.firewalls.ips.push(Target.router.local_ip)
		Target.firewalls.rules.push(firewall_rules(Target.router))

		for el in total
			for port in Target.router.device_ports(el)
				if typeof(port) != "port" then continue
				if Target.router.port_info(port).matches("unknown") then continue
				if allLanDevices.indexOf(port.port_number) != null and allLanDevices.indexOf(el) != null then continue
				allLanDevices = allLanDevices + "\n" + portIndex + " " + port.port_number + " " + "internal" + " " + Target.router.port_info(port) + " " + el
				portIndex = portIndex + 1
			end for
		end for

		
		for el in Target.router.devices_lan_ip
			if typeof(get_router(el)) == "router" then hold.push(el)
		end for

		for el in hold
			d = get_router(el).devices_lan_ip
			for e in d
				if total.indexOf(e) == null then total.push(e)
			end for
		end for

		for ip in total
			if typeof(get_router(ip)) != "router" then continue
			r = get_router(ip)
			Target.firewalls.ips.push(ip)
			Target.firewalls.rules.push(firewall_rules(r))
			for el in r.devices_lan_ip
				if el.matches(r.local_ip) then continue
				for port in r.device_ports(el)
					if typeof(port) != "port" then continue
					if r.port_info(port).matches("unknown") then continue
					if allLanDevices.indexOf(port.port_number) != null and allLanDevices.indexOf(el) != null then continue
					allLanDevices = allLanDevices + "\n" + portIndex + " " + port.port_number + " " + "internal" + " " + r.port_info(port) + " " + el
					portIndex = portIndex + 1
				end for
			end for
		end for
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NEEEDSS WOOORKS//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////printig desc/////////////////

		clear_screen()
		print ("Scanning IP: " + Target.address)

		print("Found: " + total.len + " machines connected!")
		print(get_router.bssid_name + " : " + get_router.essid_name + "\n")

		for el in total
			print(el)
		end for
		
		print("-------------------------------------------")
		for variables in format_columns(portInfo).split("\n")
			print(variables)
		end for
		print("-------------------------------------------")
		for variables in format_columns(allLanDevices).split("\n")
			print(variables)
		end for

		PrintRouterInfo = function
			if Target.firewalls.ips.len == 0 then 
				print("No firewalls detected.")
			else
				print("-------------------------------------------")
				for f in range(Target.firewalls.ips.len - 1)
					print("ROUTER")
					print(Target.firewalls.ips[f])
					if Target.firewalls.rules[f].len == 0 then 
						print("No firewall rules detected.")
					else
						out = "ACTION PORT SOURCE-IP DESTINATION-IP\n"
						for rule in Target.firewalls.rules[f]
							out = out + rule + "\n"
						end for
			
						print(format_columns(out))
					end if
					print("-------------------------------------------")
				end for
			end if
		end function

		option = 0
		while(true)
			print("<color=blue>========================================")
			print("Type <color=#AA8B02><b>info</b></color> for more info or chose a portindex")
			option = user_input("Choose port:", false, false)
			if option.trim.to_int <= pr.len and option.trim.to_int >= 1 then
				option = option.trim.to_int - 1
				if option != 0 then 
					if pr[option].is_closed then
					print("Port is closed...")
					continue
					end if
				end if
				break
			end if
			if option.trim == "info" then PrintRouterInfo
			if option.trim == "" then return menu.run
		end while

		/////////////////printig desc/////////////////

		////////////////////MAIN SETUP END////////////////////
		if option == 0 then //Option for router
		
			net_session = Current.metaxploit.net_use(Target.address)
			if not net_session then return print("Error: can't connect to net session")
			metaLib = net_session.dump_lib
			typeOfCode = metaLib.lib_name + " " + metaLib.version
			memory = MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
			memcodes = []
		

			lan_inject = Target.router.used_ports[0].get_lan_ip
		
			counter = 1
			for mem in memory
				address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")
		
				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value, lan_inject)


					if result == 1 or result == 0 then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "firewall_disable" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) == "computer" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "computer:bounce" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) == "shell" or typeof(result) == "null" or typeof(result) == "file" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")




					//if typeof(result) != "null" then
						XPLOITS.push([typeof(result), mem, value])
					//end if
					counter = counter + 1
				end for
			end for
		else
			port = pr[option].port_number
			net_session = Current.metaxploit.net_use(Target.address, port)
			if not net_session then return print("Error: can't connect to net session")
			metaLib = net_session.dump_lib
			typeOfCode = metaLib.lib_name + " " + metaLib.version
			memory = MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
			memcodes = []

			counter = 1
			for mem in memory
				address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")

				for add in address
					if add == address[0] then continue
					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					print("<color=blue>" + "<b>----------------------------------------------------</b>")
					result = metaLib.overflow(mem, value)
					if typeof(result) == "number" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + "password_change" + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					if typeof(result) != "number" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + MainFuncsForCode.checkuser(result) + " " + "<color=#00F7FF>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + mem + "</b>")
					counter = counter + 1
					XPLOITS.push([typeof(result), mem, value])
				end for
			end for
		end if
		
			print("<color=blue>" + "<b>----------------------------------------------------</b>")
		
			num = 0
			while(true)
				option = user_input("Choose a vulnerability:", false, false)
				if option.trim.to_int <= XPLOITS.len and option.trim.to_int >= 1 then
					num = option.trim.to_int - 1
					break
				end if
				if option.trim == "" then return mainFuncs.scan.run(Target.address)
			end while
		
			userInput = user_input("Do you want to pass a IP or a password?:", false, false)
			userInput = userInput.trim
		
			clear_screen()

			Handle ={}
			Handle.shell = function
				shell = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
				Current.shell = shell
				Current.computer = Current.shell.host_computer
				Current.user = MainFuncsForCode.checkuser(shell)

				ismatch = false
				for s in range(Shells.len - 1,0)
					if Shells[s].getLocalIP == shell.host_computer.local_ip and Shells[s].getPublicIP == shell.host_computer.public_ip then 
						ismatch = true
						break
					end if
				end for
				
				if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

				wasSuccessfull = true
			end function
			Handle.computer = function
				comp = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				
				if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(comp)
						if f.getType == "d" then print("<color=blue>" + f.getName)
						if f.getType == "f" then print(" =>" + f.getName)
					end for
				end if
				wasSuccessfull = true
			end function
			Handle.file = function
				file = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				
				if option == 0 then MainFuncsForCode.showAllPasswords(file)
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(file)
						if f.getType == "d" then print("<color=blue>" + f.getName)
						if f.getType == "f" then print(" =>" + f.getName)
					end for
				end if
				wasSuccessfull = true
			end function
			Handle.nothing = function
				res = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
				if typeof(res) == "file" then
					file = res
					option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
					
					if option == 0 then MainFuncsForCode.showAllPasswords(file)
						
					if option == 1 then 
						for f in MainFuncsForCode.getFiles(file)
							if f.getType == "d" then print("<color=blue>" + f.getName)
							if f.getType == "f" then print(" =>" + f.getName)
						end for
					end if
					wasSuccessfull = true
				end if
				if typeof(res) == "computer" then
					comp = res
					option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
					
					if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
						
					if option == 1 then 
						for f in MainFuncsForCode.getFiles(comp)
							if f.getType == "d" then print("<color=blue>" + f.getName)
							if f.getType == "f" then print(" =>" + f.getName)
						end for
					end if
					wasSuccessfull = true
				end if
				if typeof(res) == "shell" then 
					shell = res
					Current.shell = shell
					Current.computer = Current.shell.host_computer
					Current.user = MainFuncsForCode.checkuser(shell)
	
					ismatch = false
					for s in range(Shells.len - 1,0)
						if Shells[s].getLocalIP == shell.host_computer.local_ip and Shells[s].getPublicIP == shell.host_computer.public_ip then 
							ismatch = true
							break
						end if
					end for
					
					if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))
	
					wasSuccessfull = true
				end if
			end function

			if XPLOITS[num][0] == "null" then 
				Handle["nothing"]
			else
				Handle[XPLOITS[num][0]]
			end if

		//if not wasSuccessfull then mainFuncs.scan.run(Target.address)
	end function

	mainFuncs.cleanup = {}
	mainFuncs.cleanup.use = "Usage: cleanup"
	mainFuncs.cleanup.description = "Deletes all files in the folder\nIf the current script is located in kit only /kit will be deleted"
	mainFuncs.cleanup.run = function(x)
		colorPrefixGood = "<color=green>"
		colorPrefixBad = "<color=#FF0000df>"
		emptyRow = "\n" + colorPrefixBad + "<b>-------------------------------------------------------</b>\n"
		withLogClearText = colorPrefixGood + "<b><size=200%>Cleanup completed!</size></b>"


		currentFolder = Current.computer.File(current_path)
		currentFolderPath = currentFolder.path
		clear_screen()

		if currentFolderPath.split("/")[-1] == "kit" then
			result = currentFolder.delete
			if result == "" then print(colorPrefixGood + fileName + " got successfully deleted.")
			if result != "" then print(colorPrefixBad + fileName + " " + result)
		else
			for file in currentFolder.get_files
				fileName = file.name
				result = file.delete
				if result == "" then print(colorPrefixGood + fileName + " got successfully deleted.")
				if result != "" then print(colorPrefixBad + fileName + " " + result)
			end for
		end if


		print(emptyRow + withLogClearText + emptyRow)

	end function

	mainFuncs.clearlog = {}
	mainFuncs.clearlog.use = "Usage: clearlog"
	mainFuncs.clearlog.description = "Corrupts log file"
	mainFuncs.clearlog.run = function(x)

		info = "<size=200%>Log cleared</size>"
		emptyRow = "\n<color=#00BBFF><b>-------------------------------------------------------</b>\n"
		file = Current.computer.File("/etc/fstab")

		if file then
			logfile = file.copy("/etc", "log")
			wait(0.02)
			logfile = Current.computer.File("/etc/log")

			if logfile then
				logfile.set_content("deleted")
				logfile.move("/var", "system.log")
			else
				return print("Permissions are lacking to clear logs :()")
			end if
			
			
		else
			return print("Permissions are lacking to clear logs :()")
		end if
		print(emptyRow + info + emptyRow)
	end function

	mainFuncs.sudo = {}
	mainFuncs.sudo.use = "Usage: sudo [user]"
	mainFuncs.sudo.description = "Sudo switches user"
	mainFuncs.sudo.run = function(x)
		file = ""
		usershell = get_shell(x[0],user_input("Password: ",true,false))
		if not usershell then return print("<color=red>Failed!")
		Current.shell = usershell
		Current.computer = Current.shell.host_computer
		launch(usershell, launch_path)
	end function

	mainFuncs.lib = {}
	mainFuncs.lib.use = "Usage: lib"
	mainFuncs.lib.description = "Scan the desired libary for vulnerabilities.\nUse [all] to scan all libs"
	mainFuncs.lib.run = function(x)

		if x then
			if x[0] == "all" then return MainFuncsForCode.scanalllibs
		end if

		XPLOITS = []
		libs = []
		lipPaths = []

		option = MainFuncsForCode.chosesmth(["Select libary", "Select libary manually (Path)", "<--"], "Choose:")

		if option == 2 then return

		for lib in Current.computer.File("/lib").get_files
			if not lib.name.matches(".so") then continue

			suffix = ""
			if DEBUG then suffix = " [" + lib.has_permission("r") + lib.has_permission("w") + lib.has_permission("x") + "]"

			libs.push(lib.name + suffix)
			lipPaths.push(lib.path)
		end for

		if option == 0 then
			ress = MainFuncsForCode.chosesmth(libs, "Choose a lib")
			metaLib = Current.metaxploit.load(lipPaths[ress])
			if not metaLib then 
				if not Current.computer.File(lipPaths[ress]).has_permission("r") then return print("Could not scan " + libs[ress] + "\n<color=red>Reason: No permission!")
				return print("Could not scan " + libs[ress] + "\n<color=red>Reason: Try updating metaxploit!")
			end if
		end if

		if option == 1 then
			ress = user_input("Type path: ", false, false).trim
			if ress == "" then return
			metaLib = Current.metaxploit.load(ress)
			if not Current.computer.File(ress).has_permission("r") then return print("Could not scan " + Current.computer.File(ress).name + "\n<color=red>Reason: No permission!")
			return print("Could not scan " + Current.computer.File(ress).name + "\n<color=red>Reason: Try updating metaxploit!")
		end if


		typeOfCode = metaLib.lib_name + " " + metaLib.version
		memory = MainFuncsForCode.getmemcodes(typeOfCode, metaLib)
		clear_screen()
		memcodes = []

		for mem in memory
			address = Current.metaxploit.scan_address(metaLib, mem).split("Unsafe check: ")

			for add in address
				if add == address[0] then continue
				value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
				value = value.replace("\n", "")
				result = metaLib.overflow(mem, value)
				//if typeof(result) != "null" then
					XPLOITS.push([typeof(result), mem, value])
				//end if
			end for
		end for

		clear_screen()

		counter = 1
		for xploit in XPLOITS
			print("<color=blue>" + "<b>----------------------------------------------------</b>")
			result = metaLib.overflow(xploit[1], xploit[2])
			if typeof(result) != "null" then print(counter + ": " + "Type: " + "<B>" + "<color=orange>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + xploit[1] + "</b>")
			if typeof(result) == "null" then print(counter + ": " + "Type: " + "<B>" + "<color=red>" + typeof(result) + "</b>" + "</color>" +" at memcode: " + "<color=red>" + "<B>" + xploit[1] + "</b>")
			counter = counter + 1
		end for

		//COPY HERE######################################################
		num = 0
		while(true)
			option = user_input("Choose a vulnerability:", false, false)
			if option.trim.to_int <= XPLOITS.len and option.trim.to_int >= 1 then
				num = option.trim.to_int - 1
				break
			end if
			if option.trim == "" then return mainFuncs.lib.run
		end while

		userInput = user_input("Do you want to pass a IP or a password?:", false, false)
		userInput = userInput.trim

		clear_screen()

		if XPLOITS[num][0] == "shell" then
			shell = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
			Current.shell = shell
			Current.computer = shell.host_computer
			Current.user = MainFuncsForCode.checkuser(shell)

			ismatch = false
			for s in range(Shells.len - 1,0)
				if Shells[s].getLocalIP == shell.host_computer.local_ip and Shells[s].getPublicIP == shell.host_computer.public_ip then 
					ismatch = true
					break
				end if
			end for
			
			if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

			wasSuccessfull = true
		end if

		if XPLOITS[num][0] == "computer" then
			comp = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
			option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
			
			if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
				
			if option == 1 then 
				for f in MainFuncsForCode.getFiles(comp)
					if f.getType == "d" then print("<color=blue>" + f.getName)
					if f.getType == "f" then print(" =>" + f.getName)
				end for
			end if
			wasSuccessfull = true
		end if

		if XPLOITS[num][0] == "number" then
			metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
			wasSuccessfull = true
		end if
		if XPLOITS[num][0] == "file" then
			file = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2])
			option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
			
			if option == 0 then MainFuncsForCode.showAllPasswords(file)
				
			if option == 1 then 
				for f in MainFuncsForCode.getFiles(file)
					if f.getType == "d" then print("<color=blue>" + f.getName)
					if f.getType == "f" then print(" =>" + f.getName)
				end for
			end if
			wasSuccessfull = true
		end if


		if XPLOITS[num][0] == "null" then
			res = metaLib.overflow(XPLOITS[num][1], XPLOITS[num][2], userInput)
			if typeof(res) == "file" then
				file = res
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				
				if option == 0 then MainFuncsForCode.showAllPasswords(file)
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(file)
						if f.getType == "d" then print("<color=blue>" + f.getName)
						if f.getType == "f" then print(" =>" + f.getName)
					end for
				end if
				wasSuccessfull = true
			end if
			if typeof(res) == "computer" then
				comp = res
				option = MainFuncsForCode.chosesmth(["1: Get credentials", "2: Show files"], "Choose a option")
				
				if option == 0 then MainFuncsForCode.showAllPasswords(comp.File("/"))
					
				if option == 1 then 
					for f in MainFuncsForCode.getFiles(comp)
						if f.getType == "d" then print("<color=blue>" + f.getName)
						if f.getType == "f" then print(" =>" + f.getName)
					end for
				end if
				wasSuccessfull = true
			end if
			if typeof(res) == "shell" then 
				shell = res
				Current.shell = shell
				Current.computer = shell.host_computer
				Current.user = MainFuncsForCode.checkuser(shell)

				ismatch = false
				for s in range(Shells.len - 1,0)
					if Shells[s].getLocalIP == shell.host_computer.local_ip and Shells[s].getPublicIP == shell.host_computer.public_ip then 
						ismatch = true
						break
					end if
				end for
				
				if not ismatch then Shells.push(Shell.create(shell,shell.host_computer.public_ip,shell.host_computer.local_ip))

				wasSuccessfull = true
			end if
		end if

		if not wasSuccessfull then
			print("Exploit failed!")
		else
			print("Exploit succedeed!")
		end if
	end function

	mainFuncs.kit = {}
	mainFuncs.kit.use = "Usage: kit [launch/install]"
	mainFuncs.kit.description = "Create kit for local use on target system"
	mainFuncs.kit.run = function(x)

		CreateKit = function
			currComp = Shells[0].getShell.host_computer
			testfile = currComp.File(launch_path)
			paths = []
			names = []


			if currComp.File(current_path + "/kit") then return print("Test-kit already exists.")

			for file in MainFuncsForCode.getFiles(Shells[0].getShell, "",".Trash")
				if file.getType == "f" then 
					paths.push(file.getPath)
					names.push(file.getName)
				end if
			end for

			if names.get("metaxploit.so") then 
				metaxpath = paths[names.indexOf("metaxploit.so")]
				metaxfile = currComp.File(metaxpath)
			end if
			if names.get("crypto.so") then 
				cryptopath = paths[names.indexOf("crypto.so")]
				cryptfile = currComp.File(cryptopath)
			end if
			if names.get("aptclient.so") then 
				aptpath = paths[names.indexOf("crypto.so")]
				aptfile = currComp.File(aptpath)
			end if

			if not metaxfile then return print("Metaxploit lib is missing")
			if not cryptfile then return print("Crypto lib is missing")
			if not aptfile then return print("Aptclient.so lib is missing")
			folderpath = current_path + "/kit"

			print("Creating test kit...")
			res = currComp.create_folder(current_path, "kit")
			//currComp.File(current_path + "/kit").chmod("o+wrx")
			if res == "string" then return print("Creation of kit folder failed: " + res)
			res = metaxfile.copy(folderpath,"metaxploit.so")
			if res == "string" then return print("Creation of metaxploit.so at " + folderpath + " failed.")
			res = cryptfile.copy(folderpath,"crypto.so")
			if res == "string" then return print("Creation of crypto.so at " + folderpath + " failed.")
			res = aptfile.copy(folderpath,"aptclient.so")
			if res == "string" then return print("Creation of aptclient.so at " + folderpath + " failed.")
			res = testfile.copy(folderpath,launch_path.split("/")[-1])
			if res == "string" then return print("Creation of t at " + folderpath + " failed.")
			print("Test kit got created.")
		end function

		if not x then return print("Use kit launch/install")

		if x[0] == "install" then
			CreateKit()
		end if
		
		if x[0] == "launch" then
			if not Shells[0].getShell.host_computer.File(current_path + "/kit") then 
				userChoice = ""
				while (true)
					userChoice = user_input("Test-kit does not exist.\nDo you want to create it and proceed? y/n ", false, true).trim
					if userChoice == "" then continue
					if userChoice == "Y" or userChoice == "y" or userChoice == "y" or userChoice == "n" or userChoice == "N" then break
				end while
				if userChoice == "y" or userChoice == "Y" then 
					CreateKit()
				else
					return print("Launch kit interrupted")
				end if
			end if


			loc = MainFuncsForCode.copytotarget(Current.shell)
			wasSuccessfull = true
			clear_screen()
			launch(Current.shell, loc, "dolocalkitstuff")
			Current.shell.start_terminal
		end if


	end function

	mainFuncs.tree = {}
	mainFuncs.tree.use = "Usage: tree"
	mainFuncs.tree.description = "Shows all folders and files plus permissions"
	mainFuncs.tree.run = function(x)
		clear_screen
		output = ""
		print("<color=#96B800>========================")
		for f in MainFuncsForCode.getFiles(Current.shell)
			if f.getType == "d" then output = output + "<color=#AD0C00>" + f.getObject.permissions + " <color=blue>" + f.getName + "\n"
			if f.getType == "f" then output = output + "<color=#AD0C00>" + f.getObject.permissions + "<color=#B18700>" + "  =>" + f.getName + "\n"
		end for
		print(output)
		print("<color=#96B800>========================")
	end function

	mainFuncs.meta = {}
	mainFuncs.meta.use = "Usage: tree"//DO DESCRIPTION#############################################################
	mainFuncs.meta.description = "Shows all folders and files plus permissions"
	mainFuncs.meta.run = function(x)
		print(global.metaxlibs.len)
		// for a in range(0,global.metalib.len - 1)
		// 	print(a + " " + global.metalib[a])
		// end for
	end function

	mainFuncs.shell = {}
	mainFuncs.shell.use = "Usage: shell [show/c/rn]"
	mainFuncs.shell.description = "Use [show] to show the log of shells\nUse [c] + index to connect to desired shell\nUse [rn] to rename a shell"
	mainFuncs.shell.run = function(x)
		if x == null then return print(mainFuncs.shell.use)

		PrintAllShells = function
			for e in range(0, Shells.len - 1)
				print("<color=#00CCFF>--------------------------")
				if e == 0 then print("StartShell")
				if e != 0 then print(Shells[e].name + " " + e)
				suffix = ""
				if Shells[e].getLocalIP == Current.computer.local_ip and Shells[e].getPublicIP == Current.computer.public_ip then suffix = " <color=#8F7900>[Current]"
				print("User: " + MainFuncsForCode.checkuser(Shells[e].getShell) + suffix)
				print("Public IP: " + Shells[e].getPublicIP)
				print("Local IP: " + Shells[e].getLocalIP)
			end for
			print("<color=#00CCFF>--------------------------")
		end function

		if x[0] == "show" then
			PrintAllShells()
		end if

		if x[0] == "cleanup" then
			colorPrefixGood = "<color=green>"
			colorPrefixBad = "<color=#FF0000df>"
			emptyRow = "\n" + colorPrefixBad + "<b>-------------------------------------------------------</b>\n"
			withLogClearText = colorPrefixGood + "<b><size=200%>Cleanup completed!</size></b>"
	
			if Shells.len - 1 == 0 then return print("There are no shells to clean")

			for e in range(1,Shells.len - 1)	
				print(Shells[e].name + e + ":")
				shell = Shells[e].getShell
				path = null
				for file in MainFuncsForCode.getFiles(shell)
					if file.getName == "kit" then path = file.getPath
				end for

				if not path and DEBUG then
					print("No kit found")
				else if path then 
					kit = shell.host_computer.File(path)
					result = kit.delete

					if not kit then
						if DEBUG then return print(Shells[e].name + e + ": " + colorPrefixGood + kit.name + " not found.")
						return
					end if

					if result == "" then print(colorPrefixGood + "Kit got successfully deleted.")
					if result != "" then print(colorPrefixBad + "Kit could not be deleted " + result)

				end if

				info = "<size=200%>Log cleared</size>"
				emptyRow = "\n<color=#00BBFF><b>-------------------------------------------------------</b>\n"
				file = Shells[e].getShell.host_computer.File("/etc/fstab")

				if file then
					logfile = file.copy("/etc", "log")
					wait(0.02)
					logfile = Shells[e].getShell.host_computer.File("/etc/log")

					if logfile then
						logfile.set_content("deleted")
						logfile.move("/var", "system.log")
					else
						return print("Permissions are lacking to clear logs :()")
					end if
					
					
				else
					return print("Permissions are lacking to clear logs :()")
				end if
			end for

			print(emptyRow + withLogClearText + emptyRow)

		end if

		if x[0] == "c" and x[1] then
			if x[1].to_int < Shells.len and x[1].to_int >= 1 then

				print("<color=#00B7FF>--------------------------------------")
				print("Routing to " + Shells[x[1].to_int].name + " " + x[1] + "\nUser: " + MainFuncsForCode.checkuser(Shells[x[1].to_int].getShell) + "\nPublic IP: " +  Shells[x[1].to_int].getPublicIP + "\nLocal IP: " + Shells[x[1].to_int].getLocalIP)
				print("<color=#00B7FF>--------------------------------------")
				Current.shell = Shells[x[1].to_int].getShell
				Current.computer = Current.shell.host_computer
				
			else 
				print("Shell " + x[1] + " does not exist")
			end if
		end if

		if x[0] == "rn" then 
			PrintAllShells()
			if Shells.len <= 1 then return print("There are no shells to rename.")
			while (true)
				num = user_input("<size=80%>" + "<color=red>TEST " + "</color>" + "</size>" + "<pos=0%><voffset=-1.2em>" + "[" + Current.user + "@" + Current.computer.get_name  + "] </color>sel.:").trim
				if num.trim == "" then continue
				if num.to_int < Shells.len and num.to_int >= 1 then 
					while (true)
						userChoice = user_input("<size=80%>" + "<color=red>TEST " + "</color>" + "</size>" + "<pos=0%><voffset=-1.2em>" + "[" + Current.user + "@" + Current.computer.get_name  + "] </color>name.:").trim
						if userChoice.trim == "" then continue
						Shells[num.to_int].setName(userChoice)
						break
					end while
				end if
				break
			end while

			print("Shell " + num + " renamed to " + userChoice)
		end if
	end function

	mainFuncs.update = {}
	mainFuncs.update.use = "Usage: update"
	mainFuncs.update.description = "Updates apt client and upgrades if needed"
	mainFuncs.update.run = function(x)
		result = Current.aptclient.update()
		if result == "" then
			print("Updating aptclient was succsessful!")
		else
			return print("Updating aptclient failed: " + result)
		end if

		print("Installing metaxploit.so")
		Current.aptclient.install("metaxploit.so", current_path)
		Current.metaxploit = include_lib(current_path + "/metaxploit.so")
	
		print("Installing crypto.so")
		Current.aptclient.install("crypto.so", current_path)
		Current.crypt = include_lib(current_path + "/crypto.so")
	end function

	mainFuncs.lock = {}
	mainFuncs.lock.use = "Usage: lock"
	mainFuncs.lock.description = "Locks all files and executeables except Terminal.exe and the sudo cmd\nUse [-] to unlock all\nUse [all] to lock everything for every user"
	mainFuncs.lock.run = function(x)

		if x then
			if x[0] == "-" then 
				if not Current.computer.File("/").has_permission("w") then return print("<color=red>You have no permission to do that!")
				allFiles = MainFuncsForCode.getFiles(Current.shell)
				for file in allFiles
					file.getObject.chmod("u+wrx")
					file.getObject.chmod("o+wrx")
					file.getObject.chmod("g+wrx")
				end for
				print("<color=yellow>=================================================")
				print("<size=200%><color=blue>System unlocked!")
				print("<color=yellow>=================================================")
				return
			else if x[0] == "all" then


				while true
					userinput = user_input("This command will lock all users\nDo you want to proceed y/n\n", false, true).trim
					if userinput == "y" or userinput == "Y" then break
					return print("Process interrupted.")
				end while

				while true
					userinput = user_input("Enter password: ", true).trim
					if userinput == "" and password != "" then return print("Process interrupted.")
					if userinput != password and userinput != "" then continue
					break
				end while

				if not Current.computer.File("/").has_permission("w") then return print("<color=red>You have no permission to do that!")
				allFiles = MainFuncsForCode.getFiles(Current.shell)
				for file in allFiles
					file.getObject.chmod("u-wrx")
					file.getObject.chmod("o-wrx")
					file.getObject.chmod("g-wrx")
				end for
		
				print("<color=yellow>=================================================")
				print("<size=200%><color=blue>System locked!")
				print("<color=yellow>=================================================")
			end if
		else
			if not Current.computer.File("/").has_permission("w") then return print("<color=red>You have no permission to do that!")
			allFiles = MainFuncsForCode.getFiles(Current.shell)
			for file in allFiles
				if file.name == "passwd" or file.name == "Mail.txt" then 
					file.getObject.delete
					print(file.name + " got deleted")
					continue
				end if
				if file.name.matches("sudo") or file.name.matches("Terminal.exe") or file.name.matches("Terminal") then continue
				file.getObject.chmod("o-wrx")
				file.getObject.chmod("g-wrx")
			end for
	
			print("<color=yellow>=================================================")
			print("<size=200%><color=blue>System locked!")
			print("<color=yellow>=================================================")
		end if



	end function

	mainFuncs.exit = {}
	mainFuncs.exit.use = "Usage: exit"
	mainFuncs.exit.description = "Exits out of test script\nUse [l] to exit to the current shell\nUse [all] to exit to the start shell"
	mainFuncs.exit.run = function(x)

		if not x then
			print("<color=#00B7FF>--------------------------------------")
			print("Routing to StartShell\nPublic IP: " +  Current.computer.public_ip + "\nLocal IP: " + Current.computer.local_ip)
			print("<color=#00B7FF>--------------------------------------")
			Current.shell = Shells[0].getShell
			Current.computer = Current.shell.host_computer
		else if x[0] == "l" then 
			print()
			print("<color=#00B7FF>--------------------------------------")
			print("Routing to \nUser: " + MainFuncsForCode.checkuser(Current.shell) + "\nPublic IP: " +  Current.computer.public_ip + "\nLocal IP: " + Current.computer.local_ip)
			print("<color=#00B7FF>--------------------------------------")
			Current.shell.start_terminal
			exit("Shutting down...")
		else if x[0] == "all" then
			exit("Shutting down...")
		end if
	end function

	x = new self
	x.cmd = mainFuncs
	return x

end function

Menu.help = function
	lineColor = "<color=#004A9F>"
	print(lineColor + "------------------------------------------------------</color>")
	for each in self.cmd.indexes
		if self.cmd[each].hasIndex("run") and self.cmd[each].hasIndex("description") then print(self.cmd[each].use + "\n" + self.cmd[each].description + "\n" + lineColor + "------------------------------------------------------</color>")
	end for
end function

Menu.CommandHandler = function(command)
	command = command.split(" ")

	for a in range(command.len - 1)
		if command[a] == "" then command.remove(command.indexOf(""))
	end for

	if self.cmd.hasIndex(command[0].lower) then 
		f = @self.cmd[command[0].lower].run
		if command.len > 1 then f(command[1:]) else f
	else
		print("<color=red>Invalid command!")
	end if

end function

Menu.run = function
	while (true)
		userChoice = user_input("<size=80%>" + "<color=red>TEST " + "</color>" + "</size>" + "<pos=0%><voffset=-1.2em>" + "[" + Current.user + "@" + Current.computer.get_name  + "] </color>").trim
		if userChoice == "" then continue
		if userChoice == "-h" or userChoice == "help" then
			self.help
			continue
		end if
		self.CommandHandler(userChoice)
	end while
end function

menu = Menu.init
menu.run